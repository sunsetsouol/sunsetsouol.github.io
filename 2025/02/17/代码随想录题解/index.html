<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>代码随想录题解 | Coding Road</title><meta name="author" content="sunsetsouol"><meta name="copyright" content="sunsetsouol"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="代码随想录刷题1数组1.1二分查找1.1.1二分查找关键词：有序（升序)，不重复 思路：有序，不重复，马上就可以想到是二分查找，不断的二分缩小范围就可以找到目标值 1234567891011121314151617181920class Solution &#123;    public int search(int[] nums, int target) &#123;        if(tar">
<meta property="og:type" content="article">
<meta property="og:title" content="代码随想录题解">
<meta property="og:url" content="http://example.com/2025/02/17/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E9%A2%98%E8%A7%A3/index.html">
<meta property="og:site_name" content="Coding Road">
<meta property="og:description" content="代码随想录刷题1数组1.1二分查找1.1.1二分查找关键词：有序（升序)，不重复 思路：有序，不重复，马上就可以想到是二分查找，不断的二分缩小范围就可以找到目标值 1234567891011121314151617181920class Solution &#123;    public int search(int[] nums, int target) &#123;        if(tar">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://image.nickxu.me/202202230023069.jpg">
<meta property="article:published_time" content="2025-02-17T03:37:35.000Z">
<meta property="article:modified_time" content="2025-02-17T03:39:01.898Z">
<meta property="article:author" content="sunsetsouol">
<meta property="article:tag" content="刷题题解">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://image.nickxu.me/202202230023069.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "代码随想录题解",
  "url": "http://example.com/2025/02/17/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E9%A2%98%E8%A7%A3/",
  "image": "https://image.nickxu.me/202202230023069.jpg",
  "datePublished": "2025-02-17T03:37:35.000Z",
  "dateModified": "2025-02-17T03:39:01.898Z",
  "author": [
    {
      "@type": "Person",
      "name": "sunsetsouol",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/02/17/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E9%A2%98%E8%A7%A3/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '代码随想录题解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://qgstudio2024.oss-cn-guangzhou.aliyuncs.com/pic/202405171110049.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/todo/"><i class="fa-fw fas fa-list-alt"></i><span> ToDo</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/contact/"><i class="fa-fw fas fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://image.nickxu.me/202202230023069.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Coding Road</span></a><a class="nav-page-title" href="/"><span class="site-name">代码随想录题解</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/todo/"><i class="fa-fw fas fa-list-alt"></i><span> ToDo</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/contact/"><i class="fa-fw fas fa-comments"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">代码随想录题解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-02-17T03:37:35.000Z" title="发表于 2025-02-17 11:37:35">2025-02-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-02-17T03:39:01.898Z" title="更新于 2025-02-17 11:39:01">2025-02-17</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="代码随想录刷题"><a href="#代码随想录刷题" class="headerlink" title="代码随想录刷题"></a>代码随想录刷题</h1><h1 id="1数组"><a href="#1数组" class="headerlink" title="1数组"></a>1数组</h1><h2 id="1-1二分查找"><a href="#1-1二分查找" class="headerlink" title="1.1二分查找"></a>1.1二分查找</h2><h3 id="1-1-1二分查找"><a href="#1-1-1二分查找" class="headerlink" title="1.1.1二分查找"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-search/">1.1.1二分查找</a></h3><p>关键词：有序（升序)，不重复</p>
<p>思路：有序，不重复，马上就可以想到是二分查找，不断的二分缩小范围就可以找到目标值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int search(int[] nums, int target) &#123;</span><br><span class="line">        if(target &lt; nums[0] || target &gt; nums[nums.length - 1])&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = nums.length -1;</span><br><span class="line">        while(left &lt;= right)&#123;</span><br><span class="line">            int mid = left + ((right - left) &gt;&gt; 1);</span><br><span class="line">            if (target &gt; nums[mid])&#123;</span><br><span class="line">                left = mid + 1;</span><br><span class="line">            &#125;else if (target &lt; nums[mid])&#123;</span><br><span class="line">                right = mid - 1;</span><br><span class="line">            &#125; else&#123;</span><br><span class="line">                return mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011238157.png" alt="image-20240131210330467"></p>
<h3 id="1-1-2搜索插入位置"><a href="#1-1-2搜索插入位置" class="headerlink" title="1.1.2搜索插入位置"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-insert-position/">1.1.2搜索插入位置</a></h3><p>关键词：排序数组，升序，无重复元素</p>
<p>思路：二分查找找到该元素即可，需要注意的是数组中可能不会出现该元素，这时需要返回该元素该出现的位置，一共有以下4种情况</p>
<ol>
<li>target比数组全部元素大，索引正好为数组大小</li>
<li>target比数组全部元素小，索引为0</li>
<li>数组中存在target，直接返回target的索引</li>
<li>数组中不存在target，当left&#x3D;right，如果这个值比target大，那么right-1，应该返回left或right+1，如果这个值比target小，left++，应该返回left或right</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int searchInsert(int[] nums, int target) &#123;</span><br><span class="line">        // 如果小于最小值</span><br><span class="line">        if (target &lt; nums[0]) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果大于最大值</span><br><span class="line">        int right = nums.length - 1;</span><br><span class="line">        if (target &gt; nums[right]) &#123;</span><br><span class="line">            return nums.length;</span><br><span class="line">        &#125;</span><br><span class="line">        // 二分查找</span><br><span class="line">        int left = 0;</span><br><span class="line">        int mid;</span><br><span class="line">        while (left &lt;= right) &#123;</span><br><span class="line">            mid = left + ((right - left) &gt;&gt; 1);</span><br><span class="line">            if (target &gt; nums[mid]) &#123;</span><br><span class="line">                left = mid + 1;</span><br><span class="line">            &#125; else if (target &lt; nums[mid]) &#123;</span><br><span class="line">                right = mid - 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011240578.png" alt="image-20240131213111695"></p>
<h3 id="1-1-3在排序数组中查找元素的第一个和最后一个位置"><a href="#1-1-3在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="1.1.3在排序数组中查找元素的第一个和最后一个位置"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">1.1.3在排序数组中查找元素的第一个和最后一个位置</a></h3><p>思路：依然是二分查找，不过在找到元素后要不断的往左右二分逼近，找到全部元素</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] searchRange(int[] nums, int target) &#123;</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = nums.length -1 ;</span><br><span class="line">        int mid ;</span><br><span class="line">        int l=-1, r=-1;</span><br><span class="line">        while(left&lt;=right)&#123;</span><br><span class="line">            mid=left+((right-left)&gt;&gt;1);</span><br><span class="line">            if(target&gt;nums[mid])&#123;</span><br><span class="line">                left = mid+1;</span><br><span class="line">            &#125;else if(target&lt;nums[mid])&#123;</span><br><span class="line">                right = mid-1;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                l=mid;</span><br><span class="line">                right = mid-1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        left=0;</span><br><span class="line">        right=nums.length-1;</span><br><span class="line">        while(left&lt;=right)&#123;</span><br><span class="line">            mid=left+((right-left)&gt;&gt;1);</span><br><span class="line">            if(target&gt;nums[mid])&#123;</span><br><span class="line">                left = mid+1;</span><br><span class="line">            &#125;else if(target&lt;nums[mid])&#123;</span><br><span class="line">                right = mid-1;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                r=mid;</span><br><span class="line">                left = mid+1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return new int[]&#123;l,r&#125;;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011240836.png" alt="image-20240131213452379"></p>
<h3 id="1-1-4X的平方根"><a href="#1-1-4X的平方根" class="headerlink" title="1.1.4X的平方根"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sqrtx/">1.1.4X的平方根</a></h3><p>思路：给定的x的平方根只能存在于0到x之间，通过二分查找不断逼近找到平方小于X的最小值即可，但是要注意目标数的平方可能会超过int的范围，这时候要转换成long</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int mySqrt(int x) &#123;</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = x;</span><br><span class="line">        int mid=0;</span><br><span class="line">        long sqa=0; </span><br><span class="line">        while(left&lt;=right)&#123;</span><br><span class="line">            mid = left + ((right-left)&gt;&gt;1);</span><br><span class="line">            sqa=(long)mid*mid;</span><br><span class="line">            if(sqa&gt;x)&#123;</span><br><span class="line">                right = mid-1;</span><br><span class="line">            &#125;else if(sqa&lt;x)&#123;</span><br><span class="line">                left = mid+1;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011240508.png" alt="image-20240201110117452"></p>
<h3 id="1-1-5有效的完全平方数"><a href="#1-1-5有效的完全平方数" class="headerlink" title="1.1.5有效的完全平方数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-perfect-square/">1.1.5有效的完全平方数</a></h3><p>思路：跟上题差不多，二分查找平方等于num的数，如果找到了要返回true，找不到直接返回false即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isPerfectSquare(int num) &#123;</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = num;</span><br><span class="line">        int mid=0;</span><br><span class="line">        long sqa;</span><br><span class="line">        while(left&lt;=right)&#123;</span><br><span class="line">            mid = left+((right-left)&gt;&gt;1);</span><br><span class="line">            sqa=(long)mid*mid;</span><br><span class="line">            if(sqa&gt;num)&#123;</span><br><span class="line">                right = mid-1;</span><br><span class="line">            &#125;else if (sqa&lt;num)&#123;</span><br><span class="line">                left = mid+1;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011240072.png" alt="image-20240131213900700"></p>
<h2 id="1-2移除元素"><a href="#1-2移除元素" class="headerlink" title="1.2移除元素"></a>1.2移除元素</h2><h3 id="1-2-1移除元素"><a href="#1-2-1移除元素" class="headerlink" title="1.2.1移除元素"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-element/">1.2.1移除元素</a></h3><p>思路：看到这道题最先的思路是用一个指针遍历数组，遇到val后直接往后找到第一个不等于val的元素，然后进行交换，但是每次都要从val开始往后遍历会重复走很多步，时间复杂度也是O（n^2)，这时候用双指针就可以解决这个问题，快指针遍历元素找到全部非val元素，慢指针维护一段不含val的数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int removeElement(int[] nums, int val) &#123;</span><br><span class="line">        if(nums.length == 0)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int fast = 0;</span><br><span class="line">        int slow = 0;</span><br><span class="line">        while(fast &lt; nums.length)&#123;</span><br><span class="line">            nums[slow] = nums[fast];</span><br><span class="line">            if(nums[fast++] != val)&#123;</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return slow ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011240191.png" alt="image-20240131220915930"></p>
<h3 id="1-2-2删除排序数组中的重复项"><a href="#1-2-2删除排序数组中的重复项" class="headerlink" title="1.2.2删除排序数组中的重复项"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">1.2.2删除排序数组中的重复项</a></h3><p>思路：还是双指针遍历，快指针找到不是重复的元素，然后赋值交换给慢指针，最后返回根据慢指针的索引确定k的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int removeDuplicates(int[] nums) &#123;</span><br><span class="line">        int slow = 0;</span><br><span class="line">        int fast = 0;</span><br><span class="line">        int n = nums.length - 1;</span><br><span class="line">        while(fast &lt; nums.length)&#123;</span><br><span class="line">            nums[slow] = nums [fast];</span><br><span class="line">            while(fast &lt; n &amp;&amp; nums[fast] == nums[fast+1])&#123;</span><br><span class="line">                fast++;</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">            slow++;</span><br><span class="line">        &#125;</span><br><span class="line">        return slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011242125.png" alt="image-20240131223958198"></p>
<h3 id="1-2-3移动零"><a href="#1-2-3移动零" class="headerlink" title="1.2.3移动零"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/move-zeroes/">1.2.3移动零</a></h3><p>思路：还是快慢指针将0维护在快慢指针中间的位置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void moveZeroes(int[] nums) &#123;</span><br><span class="line">        int slow = 0;</span><br><span class="line">        int fast = 0;</span><br><span class="line">        while(fast &lt; nums.length)&#123;</span><br><span class="line">            if(nums[fast] != 0)&#123;</span><br><span class="line">                int tem = nums[slow];</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                nums[fast] = tem;</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011242812.png" alt="image-20240131224137123"></p>
<h3 id="1-2-4比较含退格的字符串"><a href="#1-2-4比较含退格的字符串" class="headerlink" title="1.2.4比较含退格的字符串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/backspace-string-compare/">1.2.4比较含退格的字符串</a></h3><p>思路：用双指针将字符串重构成有效字符串，然后比较两个字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean backspaceCompare(String s, String t) &#123;</span><br><span class="line">        if(getString(s.toCharArray()).equals(getString(t.toCharArray())))&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public String getString(char[] a)&#123;</span><br><span class="line">        int slow = 0;</span><br><span class="line">        int fast = 0;</span><br><span class="line">        while(fast &lt; a.length)&#123;</span><br><span class="line">            if(a[fast] != &#x27;#&#x27;)&#123;</span><br><span class="line">                a[slow] = a[fast];</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                slow = Math.max(slow-1,0);</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        return new String(a,0,slow);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011243590.png" alt="image-20240131225327146"></p>
<h2 id="1-3有序数组的平方"><a href="#1-3有序数组的平方" class="headerlink" title="1.3有序数组的平方"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/squares-of-a-sorted-array/">1.3有序数组的平方</a></h2><p>思路：如果数组是从零开始，那么每个数平方后大小顺序也是不变的，但是数组可能存在负数的情况，那么很自然的想到找到平方最小的数然后向左右遍历选出平方较小值插入到新数组中，但是找到最小的元素比较麻烦，所以可以反过来寻找，从头尾开始往中间找，先找到最大的元素，慢慢找到中间小的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] sortedSquares(int[] nums) &#123;</span><br><span class="line">        int[] res= new int[nums.length];</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = nums.length - 1;</span><br><span class="line">        int index = nums.length - 1;</span><br><span class="line">        while(left &lt;= right)&#123;</span><br><span class="line">            if(nums[right] * nums[right] &gt; nums[left] * nums[left])&#123;</span><br><span class="line">                res[index--] = nums[right] * nums[right--];</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                res[index--] = nums[left] * nums[left++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011243294.png" alt="image-20240131225635624"></p>
<h2 id="1-4长度最小的子数组"><a href="#1-4长度最小的子数组" class="headerlink" title="1.4长度最小的子数组"></a>1.4长度最小的子数组</h2><h3 id="1-4-1长度最小的子数组"><a href="#1-4-1长度最小的子数组" class="headerlink" title="1.4.1长度最小的子数组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-size-subarray-sum/">1.4.1长度最小的子数组</a></h3><p>思路：用两个指针维护一个滑动窗口，找到满足条件的子数组然后记录长度最小的子数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int minSubArrayLen(int target, int[] nums) &#123;</span><br><span class="line">        int len = nums.length;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for(int left = 0, right = 0; right&lt;nums.length;right++)&#123;</span><br><span class="line">            sum += nums[right];</span><br><span class="line">            while(sum &gt;= target)&#123;</span><br><span class="line">                sum-=nums[left];</span><br><span class="line">                len = Math.min(right - left, len);</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return len == nums.length ? 0 : len+1; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011243211.png" alt="image-20240131230900016"></p>
<h3 id="1-4-2水果成篮"><a href="#1-4-2水果成篮" class="headerlink" title="1.4.2水果成篮"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/fruit-into-baskets/">1.4.2水果成篮</a></h3><p>思路：还是用双指针维护一个滑动窗口找到最长的子数组，可以用map记录一个值出现的次数，并且维护滑动窗口的key小于等于2，找到最大的滑动窗口即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int totalFruit(int[] fruits) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; maps = new HashMap&lt;&gt;();</span><br><span class="line">        int left = 0;</span><br><span class="line">        int length =0;</span><br><span class="line">        for(int right = 0; right&lt;fruits.length;right++)&#123;</span><br><span class="line">            maps.put(fruits[right], maps.getOrDefault(fruits[right],0) + 1);</span><br><span class="line">            while(maps.size() &gt; 2)&#123;</span><br><span class="line">                if(maps.get(fruits[left]) &gt; 1)&#123;</span><br><span class="line">                    maps.put(fruits[left], maps.get(fruits[left]) -1);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    maps.remove(fruits[left]);</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            length=Math.max(length, right - left + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        return length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011243281.png" alt="image-20240131231223178"></p>
<h3 id="1-4-3最小覆盖字串"><a href="#1-4-3最小覆盖字串" class="headerlink" title="1.4.3最小覆盖字串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-window-substring/">1.4.3最小覆盖字串</a></h3><p>思路：还是用滑动窗口和map解决这个问题，用map记录t中字符出现的次数，然后用滑动窗口寻找字串，快指针往后遍历先判断该字符是否存在于于map，如果存在则将次数减一，慢指针就遇见就加一，找到最小的字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String minWindow(String s, String t) &#123;</span><br><span class="line">        char[] charArray = t.toCharArray();</span><br><span class="line">        Map&lt;Character, Integer&gt; target =  new HashMap&lt;&gt;();</span><br><span class="line">        for (char c : charArray) &#123;</span><br><span class="line">            target.put(c, target.getOrDefault(c, 0) + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        int left = 0;</span><br><span class="line">        int len = Integer.MAX_VALUE;</span><br><span class="line">        int lres = 0;</span><br><span class="line">        int rres = 0;</span><br><span class="line">        for(int right = 0; right &lt; s.length(); right++) &#123;</span><br><span class="line">            if (!target.containsKey(s.charAt(right)))&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            target.put(s.charAt(right), target.get(s.charAt(right)) - 1);</span><br><span class="line">            while (check(target)) &#123;</span><br><span class="line">                if (right - left + 1 &lt; len)&#123;</span><br><span class="line">                    len = right - left + 1;</span><br><span class="line">                    lres = left;</span><br><span class="line">                    rres = right;</span><br><span class="line">                &#125;</span><br><span class="line">                if (target.containsKey(s.charAt(left)))&#123;</span><br><span class="line">                    target.put(s.charAt(left), target.get(s.charAt(left)) + 1);</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return len == Integer.MAX_VALUE ? &quot;&quot; : s.substring(lres,rres +1);</span><br><span class="line">    &#125;</span><br><span class="line">    Boolean check(Map&lt;Character, Integer&gt; target)&#123;</span><br><span class="line">        for (Map.Entry&lt;Character, Integer&gt; entry : target.entrySet()) &#123;</span><br><span class="line">            if (entry.getValue() &gt; 0)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011243181.png" alt="image-20240131232559890"></p>
<h2 id="1-5螺旋矩阵"><a href="#1-5螺旋矩阵" class="headerlink" title="1.5螺旋矩阵"></a>1.5螺旋矩阵</h2><h3 id="1-5-1螺旋矩阵Ⅱ"><a href="#1-5-1螺旋矩阵Ⅱ" class="headerlink" title="1.5.1螺旋矩阵Ⅱ"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/spiral-matrix-ii/">1.5.1螺旋矩阵Ⅱ</a></h3><p>思路：这种题没什么算法思想考察，主要看对边界的判定和处理，这道题直接创建出二维数组然后照着四个方向循环遍历输出即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">// 方式yi</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int[][] generateMatrix(int n) &#123;</span><br><span class="line">        int[][] res = new int[n][n];</span><br><span class="line">        int end = n*n;</span><br><span class="line">        int cur = 1;</span><br><span class="line">        int i=0;</span><br><span class="line">        int j =0;</span><br><span class="line">        while(cur &lt; end)&#123;</span><br><span class="line">            while(j+1&lt;n &amp;&amp; res[i][j+1]==0 &amp;&amp; cur &lt; end) res[i][j++] = cur++;</span><br><span class="line">            while(i+1&lt;n &amp;&amp; res[i+1][j]==0 &amp;&amp; cur &lt; end) res[i++][j] = cur++;</span><br><span class="line">            while(j&gt;0   &amp;&amp; res[i][j-1]==0 &amp;&amp; cur &lt; end) res[i][j--] = cur++;</span><br><span class="line">            while(i&gt;0   &amp;&amp; res[i-1][j]==0 &amp;&amp; cur &lt; end) res[i--][j] = cur++;</span><br><span class="line">        &#125;</span><br><span class="line">        res[i][j]= cur;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 方式二</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int[][] generateMatrix(int n) &#123;</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = n - 1;</span><br><span class="line">        int top = 0;</span><br><span class="line">        int bottom = n - 1;</span><br><span class="line">        int[][] matrix = new int[n][n];</span><br><span class="line">        int cur = 1;</span><br><span class="line">        int end = n * n;</span><br><span class="line">        int i = top;</span><br><span class="line">        int j = left -1;</span><br><span class="line">        while(cur &lt;= end) &#123;</span><br><span class="line">            while (j &lt; right &amp;&amp; cur &lt;= end) matrix[i][++j] = cur++;</span><br><span class="line">            ++top;</span><br><span class="line">            while (i &lt; bottom &amp;&amp; cur &lt;= end) matrix[++i][j] = cur++;</span><br><span class="line">            --right;</span><br><span class="line">            while (j &gt; left &amp;&amp; cur &lt;= end) matrix[i][--j] = cur++;</span><br><span class="line">            --bottom;</span><br><span class="line">            while (i &gt; top &amp;&amp; cur &lt;= end) matrix[--i][j] = cur++;</span><br><span class="line">            ++left;</span><br><span class="line">        &#125;</span><br><span class="line">        return matrix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011243359.png" alt="image-20240131233009609"></p>
<h3 id="1-5-2螺旋矩阵"><a href="#1-5-2螺旋矩阵" class="headerlink" title="1.5.2螺旋矩阵"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/spiral-matrix/">1.5.2螺旋矩阵</a></h3><p>思路：用四个值记录数组的上下左右边，然后按照四个方向遍历添加，当上到下边重合或左右边重合即为最后一段遍历</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123;</span><br><span class="line">        int top = 0;</span><br><span class="line">        int bottom = matrix.length-1;</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = matrix[0].length-1;</span><br><span class="line">        int end = matrix.length * matrix[0].length;</span><br><span class="line">        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        while(top &lt;= bottom || left &lt;= right)&#123;</span><br><span class="line">            for(int i=left;i&lt;=right&amp;&amp;top&lt;=bottom;i++) &#123;res.add(matrix[top][i]);&#125;</span><br><span class="line">            top++;</span><br><span class="line">            for(int i = top; i&lt;=bottom&amp;&amp;left&lt;=right; i++)&#123; res.add(matrix[i][right]);&#125;</span><br><span class="line">            right--;</span><br><span class="line">            for(int i=right;i&gt;=left&amp;&amp;top&lt;=bottom;i--) &#123;res.add(matrix[bottom][i]);&#125;</span><br><span class="line">            bottom--;</span><br><span class="line">            for(int i = bottom; i&gt;= top&amp;&amp;left&lt;=right; i--)&#123; res.add(matrix[i][left]);&#125;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011244219.png" alt="image-20240131233323456"></p>
<h3 id="1-5-3顺时针打印矩阵"><a href="#1-5-3顺时针打印矩阵" class="headerlink" title="1.5.3顺时针打印矩阵"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/">1.5.3顺时针打印矩阵</a></h3><p>思路：跟上题基本一致，四个值记录四条边界然后四个方向循环记录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] spiralArray(int[][] array) &#123;</span><br><span class="line">        if(array.length == 0)&#123;</span><br><span class="line">            return new int[]&#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        int top=0;</span><br><span class="line">        int bottom=array.length-1;</span><br><span class="line">        int left=0;</span><br><span class="line">        int right=array[0].length-1;</span><br><span class="line">        int[] res=new int[array.length*array[0].length];</span><br><span class="line">        int cur=0;</span><br><span class="line">        while(top&lt;=bottom||left&lt;=right)&#123;</span><br><span class="line">            for(int i=left;i&lt;=right&amp;&amp;top&lt;=bottom;i++) res[cur++]=array[top][i];</span><br><span class="line">            top++;</span><br><span class="line">            for(int i=top;i&lt;=bottom&amp;&amp;left&lt;=right;i++) res[cur++]=array[i][right];</span><br><span class="line">            right--;</span><br><span class="line">            for(int i=right;i&gt;=left&amp;&amp;top&lt;=bottom;i--) res[cur++]=array[bottom][i];</span><br><span class="line">            bottom--;</span><br><span class="line">            for(int i=bottom;i&gt;=top&amp;&amp;left&lt;=right;i--) res[cur++]=array[i][left];</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011244088.png" alt="image-20240131233504800"></p>
<h1 id="2-链表"><a href="#2-链表" class="headerlink" title="2.链表"></a>2.链表</h1><h2 id="2-1移除链表元素"><a href="#2-1移除链表元素" class="headerlink" title="2.1移除链表元素"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-linked-list-elements/">2.1移除链表元素</a></h2><p>思路：简单遍历，找到目标元素时指向他的next，为了防止处理头节点为null的情况，可以添加一个虚拟头节点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode removeElements(ListNode head, int val) &#123;</span><br><span class="line">        // 雅指针</span><br><span class="line">        ListNode p = new ListNode(0);</span><br><span class="line">        p.next = head;</span><br><span class="line">        head=p;</span><br><span class="line">        ListNode cur = p.next;</span><br><span class="line">        while(cur!=null)&#123;</span><br><span class="line">            if(cur.val==val)&#123;</span><br><span class="line">                p.next=cur.next;</span><br><span class="line">                cur=p.next;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                p=cur;</span><br><span class="line">                cur=p.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011244570.png" alt="image-20240201000025431"></p>
<h2 id="2-2设计链表"><a href="#2-2设计链表" class="headerlink" title="2.2设计链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/design-linked-list/">2.2设计链表</a></h2><p>思路：头尾指针都设置一个虚拟节点解决边界特判，然后记录一下数组大小就好了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">class MyLinkedList &#123;</span><br><span class="line"></span><br><span class="line">    class ListNode &#123;</span><br><span class="line">        int val;</span><br><span class="line">        ListNode pre;</span><br><span class="line">        ListNode next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode head;</span><br><span class="line">    ListNode tail;</span><br><span class="line"></span><br><span class="line">    int size;</span><br><span class="line"></span><br><span class="line">    public MyLinkedList() &#123;</span><br><span class="line">        this.head = new ListNode();</span><br><span class="line">        this.tail = new ListNode();</span><br><span class="line">        this.head.next = tail;</span><br><span class="line">        this.tail.pre = head;</span><br><span class="line">        this.size = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int get(int index) &#123;</span><br><span class="line">        if (index &gt;= size ) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode p = head;</span><br><span class="line">        for (int i = 0; i &lt;= index; i++) &#123;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return p.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addAtHead(int val) &#123;</span><br><span class="line">        ListNode p = new ListNode();</span><br><span class="line">        p.val = val;</span><br><span class="line"></span><br><span class="line">        p.next = head.next;</span><br><span class="line">        head.next = p;</span><br><span class="line"></span><br><span class="line">        p.pre = head;</span><br><span class="line">        p.next.pre = p;</span><br><span class="line"></span><br><span class="line">        this.size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addAtTail(int val) &#123;</span><br><span class="line">        ListNode p = new ListNode();</span><br><span class="line">        p.val = val;</span><br><span class="line"></span><br><span class="line">        p.pre = tail.pre;</span><br><span class="line">        tail.pre = p;</span><br><span class="line"></span><br><span class="line">        p.pre.next = p;</span><br><span class="line">        p.next = tail;</span><br><span class="line"></span><br><span class="line">        this.size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addAtIndex(int index, int val) &#123;</span><br><span class="line">        if(index &gt; size)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode node = new ListNode();</span><br><span class="line">        node.val = val;</span><br><span class="line">        </span><br><span class="line">        ListNode p = head;</span><br><span class="line">        for(int i = 0; i &lt;= index; i++)&#123;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        node.pre = p.pre;</span><br><span class="line">        p.pre = node;</span><br><span class="line">        </span><br><span class="line">        node.pre.next = node;</span><br><span class="line">        node.next = p;</span><br><span class="line">        </span><br><span class="line">        this.size++;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void deleteAtIndex(int index) &#123;</span><br><span class="line">        if(index &gt;= size)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode p = head;</span><br><span class="line">        for(int i = 0; i &lt;= index; i++)&#123;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        p.pre.next = p.next;</span><br><span class="line">        p.next.pre = p.pre;</span><br><span class="line">        </span><br><span class="line">        this.size--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3翻转链表"><a href="#2-3翻转链表" class="headerlink" title="2.3翻转链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list/">2.3翻转链表</a></h2><p>思路1：直接翻转，遍历链表，保存好当前节点的下一个节点，然后将当前节点的next指向上一个节点，迭代即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode reverseList(ListNode head) &#123;</span><br><span class="line">        ListNode pre = null;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        ListNode next ;</span><br><span class="line">        while(cur!=null)&#123;</span><br><span class="line">            next = cur.next;</span><br><span class="line">            cur.next=pre;</span><br><span class="line">            pre=cur;</span><br><span class="line">            cur=next;</span><br><span class="line">        &#125;</span><br><span class="line">        return pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路2：头插法，遍历链表，将遍历到的节点直接头插到新的链表，得到的新链表就是原链表翻转后的结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode reverseList(ListNode head) &#123;</span><br><span class="line">        ListNode p = new ListNode();</span><br><span class="line">        ListNode q;</span><br><span class="line">        while(head!=null)&#123;</span><br><span class="line">            q=head.next;</span><br><span class="line">            head.next=p.next;</span><br><span class="line">            p.next=head;</span><br><span class="line">            head=q;</span><br><span class="line">        &#125;</span><br><span class="line">        return p.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路3：用栈先进后出的特性解决，将链表节点全部入栈，然后出栈组成新链表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode reverseList(ListNode head) &#123;</span><br><span class="line">        if(head==null||head.next==null)&#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;ListNode&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        while(head!=null)&#123;</span><br><span class="line">            stack.push(head);</span><br><span class="line">            head=head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode h = stack.pop();</span><br><span class="line">        ListNode p = stack.pop();</span><br><span class="line">        h.next = p;</span><br><span class="line">        while(stack.size()!=0)&#123;</span><br><span class="line">            p.next=stack.pop();</span><br><span class="line">            p=p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p.next=null;</span><br><span class="line">        return h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011244012.png" alt="image-20240201002020811"></p>
<h2 id="2-4两两交换链表中的节点"><a href="#2-4两两交换链表中的节点" class="headerlink" title="2.4两两交换链表中的节点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/swap-nodes-in-pairs/">2.4两两交换链表中的节点</a></h2><p>思路1：跟上题思路1类似，只是每次取出两个节点翻转</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode swapPairs(ListNode head) &#123;</span><br><span class="line">        if(head==null||head.next==null)&#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode p = new ListNode();</span><br><span class="line">        p.next=head;</span><br><span class="line">        ListNode pre = p;</span><br><span class="line">        ListNode left = head;</span><br><span class="line">        ListNode right ;</span><br><span class="line">        ListNode next;</span><br><span class="line">        while(left!=null&amp;&amp;left.next!=null)&#123;</span><br><span class="line">            right = left.next;</span><br><span class="line">            next=right.next;</span><br><span class="line">            pre.next = right;</span><br><span class="line">            right.next=left;</span><br><span class="line">            left.next=next;</span><br><span class="line">            pre=left;</span><br><span class="line">            left=next;</span><br><span class="line">        &#125;</span><br><span class="line">        return p.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路2：跟上题思路2类似，每次取出两个节点头插</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode swapPairs(ListNode head) &#123;</span><br><span class="line">        ListNode head2 = new ListNode();</span><br><span class="line">        head2.next=head;</span><br><span class="line">        ListNode tail=head2;</span><br><span class="line">        ListNode left,right;</span><br><span class="line">        while(head!=null&amp;&amp;head.next!=null)&#123;</span><br><span class="line">            left = head;</span><br><span class="line">            right = head.next;</span><br><span class="line">            head=right.next;</span><br><span class="line">            tail.next=right;</span><br><span class="line">            left.next=right.next;</span><br><span class="line">            right.next=left;</span><br><span class="line">            tail=left;</span><br><span class="line">        &#125;</span><br><span class="line">        return head2.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路3：跟上题思路3类似，但是是用队列每次取出两个节点，这里就不放代码了</p>
<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011244947.png" alt="image-20240201002307118"></p>
<h2 id="2-5删除链表中倒数第N个节点"><a href="#2-5删除链表中倒数第N个节点" class="headerlink" title="2.5删除链表中倒数第N个节点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">2.5删除链表中倒数第N个节点</a></h2><p>思路：快慢指针，先让快指针往后走N个元素，然后快慢指针以同样的速度往后遍历，当快指针到达最后一个节点的时候慢指针就是倒数前n+1个节点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode removeNthFromEnd(ListNode head, int n) &#123;</span><br><span class="line">        ListNode p = new ListNode();</span><br><span class="line">        p.next = head;</span><br><span class="line">        ListNode fast = p;</span><br><span class="line">        ListNode slow = p;</span><br><span class="line">        for(int i =0;i&lt;=n;i++)&#123;</span><br><span class="line">            fast=fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        while(fast!=null)&#123;</span><br><span class="line">            fast=fast.next;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow.next=slow.next.next;</span><br><span class="line">        return p.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011244024.png" alt="image-20240201002642968"></p>
<h2 id="2-6链表相交"><a href="#2-6链表相交" class="headerlink" title="2.6链表相交"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/">2.6链表相交</a></h2><p>思路：两个链表最后有公共部分，那么相等的时候他们距离链表尾的距离是一样的，那么可以先遍历两个链表，然后得到两个链表的长度，然后让长的先往后走数值等于链表长度只差个节点，然后一起往后遍历比较是否相等</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;</span><br><span class="line">        ListNode a = headA;</span><br><span class="line">        ListNode b = headB;</span><br><span class="line">        int lena=0;</span><br><span class="line">        int lenb=0;</span><br><span class="line">        while(a!=null)&#123;</span><br><span class="line">            lena++;</span><br><span class="line">            a=a.next;</span><br><span class="line">        &#125;</span><br><span class="line">        while(b!=null)&#123;</span><br><span class="line">            lenb++;</span><br><span class="line">            b=b.next;</span><br><span class="line">        &#125;</span><br><span class="line">        a=headA;</span><br><span class="line">        b=headB;</span><br><span class="line">        if(lena&gt;lenb)&#123;</span><br><span class="line">            for(int i =lena-lenb;i&gt;0;i--)&#123;</span><br><span class="line">                a=a.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            for(int i=lenb-lena;i&gt;0;i--)&#123;</span><br><span class="line">                b=b.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while(a!= null)&#123;</span><br><span class="line">            if(a==b)&#123;</span><br><span class="line">                return a;</span><br><span class="line">            &#125;</span><br><span class="line">            a=a.next;</span><br><span class="line">            b=b.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是看了官方的题解，虽然时间上都是O（n），但是代码量少了很多，处理方式也更优雅</p>
<p>两个链表直接同步往后遍历，到达链表尾部后从另一个链表头继续遍历，比较两个指针是否相等，相当于把一个链表拼接在了对方链表的最后，这样他们的总长度都是两个链表之和，就可以直接比较是否相等了，从代码量上看明显优雅了很多</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;</span><br><span class="line">        ListNode a=headA;</span><br><span class="line">        ListNode b=headB;</span><br><span class="line">        while(a!=b)&#123;</span><br><span class="line">            a=a==null?headB:a.next;</span><br><span class="line">            b=b==null?headA:b.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-7环形链表"><a href="#2-7环形链表" class="headerlink" title="2.7环形链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle-ii/">2.7环形链表</a></h2><p>思路：这道题可以分成两部分一部分是判断链表是否成环，判断成环后还要判断环形的起点，判断是否成环用快慢指针很快就可以判断出来，但是找到环形的节点就要用点数学推导</p>
<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011245974.png" alt="fig1"></p>
<p>fast&#x3D;a+m*(b+c)+b</p>
<p>slow&#x3D;a+b</p>
<p>fast&#x3D;2*slow</p>
<p>联立上面三式 : a+b&#x3D;m*(b+c)   &#x3D;&#x3D;&gt;a&#x3D;(m-1)*b + m*c</p>
<p>当m&#x3D;1时，a&#x3D;c，所以快慢指针相遇后只需要从头节点同步遍历，相遇的交点即为环的头节点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public ListNode detectCycle(ListNode head) &#123;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        while(fast!=null &amp;&amp; fast.next!=null)&#123;</span><br><span class="line">            fast=fast.next.next;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">            if(fast==slow)&#123;</span><br><span class="line">                fast=head;</span><br><span class="line">                while(fast!=slow)&#123;</span><br><span class="line">                    fast=fast.next;</span><br><span class="line">                    slow=slow.next;</span><br><span class="line">                &#125;</span><br><span class="line">                return fast;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011245047.png" alt="image-20240201004403122"></p>
<h1 id="3-哈希表"><a href="#3-哈希表" class="headerlink" title="3.哈希表"></a>3.哈希表</h1><h2 id="3-1有效的字母异味词"><a href="#3-1有效的字母异味词" class="headerlink" title="3.1有效的字母异味词"></a>3.1有效的字母异味词</h2><h3 id="3-1-1有效的字母异味词"><a href="#3-1-1有效的字母异味词" class="headerlink" title="3.1.1有效的字母异味词"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-anagram/">3.1.1有效的字母异味词</a></h3><p>思路：用哈希表记录字符串字符的出现次数，用s进行插入，t进行删除，最后看一下哈希表是否还有元素即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isAnagram(String s, String t) &#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; smap = new HashMap&lt;&gt;();</span><br><span class="line">        char[] sChars = s.toCharArray();</span><br><span class="line">        for(char sChar:sChars)&#123;</span><br><span class="line">            if(smap.containsKey(sChar))&#123;</span><br><span class="line">                smap.put(sChar,smap.get(sChar) + 1);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                smap.put(sChar,1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        char[] tChars = t.toCharArray();</span><br><span class="line">        for(char tChar:tChars)&#123;</span><br><span class="line">            if(!smap.containsKey(tChar))&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                if(smap.get(tChar)&gt;1)&#123;</span><br><span class="line">                    smap.put(tChar, smap.get(tChar) -1);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    smap.remove(tChar);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(smap.isEmpty())&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011245998.png" alt="image-20240201133143719"></p>
<p>思考：这道题字符其实是有限的而且并不多，可以用桶排的思想，直接用数组记录全部字符的次数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isAnagram(String s, String t) &#123;</span><br><span class="line">        if(s.length()!=t.length())&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        int[] a = new int[26];</span><br><span class="line">        char[]sChars = s.toCharArray();</span><br><span class="line">        for(char sChar:sChars)&#123;</span><br><span class="line">            ++a[sChar-&#x27;a&#x27;];</span><br><span class="line">        &#125;</span><br><span class="line">        for(char tChar:t.toCharArray())&#123;</span><br><span class="line">            if(--a[tChar-&#x27;a&#x27;]&lt;0)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011245622.png" alt="image-20240201133721085"></p>
<h3 id="3-1-2赎金信"><a href="#3-1-2赎金信" class="headerlink" title="3.1.2赎金信"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ransom-note/">3.1.2赎金信</a></h3><p>思路1：还是跟上面用哈希表记录字符个数一样，一个插入，一个删除，最后查看哈希表是否为空</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean canConstruct(String ransomNote, String magazine) &#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        for(char ch:ransomNote.toCharArray())&#123;</span><br><span class="line">            map.put(ch, map.getOrDefault(ch,0)+1);</span><br><span class="line">        &#125;</span><br><span class="line">        for(char ch:magazine.toCharArray())&#123;</span><br><span class="line">            map.put(ch, map.getOrDefault(ch,0)-1);</span><br><span class="line">            if(map.get(ch)&lt;=0)&#123;</span><br><span class="line">                map.remove(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(map.isEmpty())&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011245689.png" alt="image-20240201135157260"></p>
<p>思路2：跟上面的改进一样，用桶排的思想记录字符个数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean canConstruct(String ransomNote, String magazine) &#123;</span><br><span class="line">        int[] a = new int[26];</span><br><span class="line">        for(char ch:magazine.toCharArray())&#123;</span><br><span class="line">            ++a[ch-&#x27;a&#x27;];</span><br><span class="line">        &#125;</span><br><span class="line">        for(char ch:ransomNote.toCharArray())&#123;</span><br><span class="line">            if(--a[ch-&#x27;a&#x27;]&lt;0)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="3-1-3字母异位词分组"><a href="#3-1-3字母异位词分组" class="headerlink" title="3.1.3字母异位词分组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/group-anagrams/">3.1.3字母异位词分组</a></h3><p>思路：最简单的方法就是双重循环逐个判断是否为异位词，但是双重循环加上判断异位词会导致时间复杂度是O（n^3）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">        for(int i =0;i&lt;strs.length;i++)&#123;</span><br><span class="line">            if(strs[i]==null)&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">            ans.add(list);</span><br><span class="line">            list.add(strs[i]);</span><br><span class="line">            for(int j=i+1;j&lt;strs.length;j++)&#123;</span><br><span class="line">                if(strs[j]==null)&#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if(isAnagram(strs[i],strs[j]))&#123;</span><br><span class="line">                    list.add(strs[j]);</span><br><span class="line">                    strs[j]=null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean isAnagram(String s, String t) &#123;</span><br><span class="line">        if(s.length()!=t.length())&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        int[] a = new int[26];</span><br><span class="line">        char[]sChars = s.toCharArray();</span><br><span class="line">        for(char sChar:sChars)&#123;</span><br><span class="line">            ++a[sChar-&#x27;a&#x27;];</span><br><span class="line">        &#125;</span><br><span class="line">        for(char tChar:t.toCharArray())&#123;</span><br><span class="line">            if(--a[tChar-&#x27;a&#x27;]&lt;0)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011245977.png" alt="image-20240201164314227"></p>
<p>思路2：可以把原字符串全部先排序，排序之后的异位词就全部都是相等的了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">        Map&lt;String,List&lt;String&gt;&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        for(String str:strs)&#123;</span><br><span class="line">            char[] ch = str.toCharArray();</span><br><span class="line">            Arrays.sort(ch);</span><br><span class="line">            String newString = new String(ch);</span><br><span class="line">            List&lt;String&gt; list = map.getOrDefault(newString, new ArrayList&lt;&gt;());</span><br><span class="line">            list.add(str);</span><br><span class="line">            map.put(newString,list);</span><br><span class="line">        &#125;</span><br><span class="line">        return new ArrayList&lt;&gt;(map.values());</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011245356.png" alt="image-20240201165735978"></p>
<h3 id="3-1-4找到字符串中所有字母异位词"><a href="#3-1-4找到字符串中所有字母异位词" class="headerlink" title="3.1.4找到字符串中所有字母异位词"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">3.1.4找到字符串中所有字母异位词</a></h3><p>思路：滑动窗口维护一个一个字串然后比较他们是否为异位词即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; findAnagrams(String s, String p) &#123;</span><br><span class="line">        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">        for(int i =0;i&lt;=s.length()-p.length();i++)&#123;</span><br><span class="line">            String newString = s.substring(i,i+p.length());</span><br><span class="line">            if(isAnagram(newString, p))&#123;</span><br><span class="line">                 ans.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public boolean isAnagram(String s, String t) &#123;</span><br><span class="line">        if(s.length()!=t.length())&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        int[] a = new int[26];</span><br><span class="line">        char[]sChars = s.toCharArray();</span><br><span class="line">        for(char sChar:sChars)&#123;</span><br><span class="line">            ++a[sChar-&#x27;a&#x27;];</span><br><span class="line">        &#125;</span><br><span class="line">        for(char tChar:t.toCharArray())&#123;</span><br><span class="line">            if(--a[tChar-&#x27;a&#x27;]&lt;0)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011246054.png" alt="image-20240201174817610"></p>
<p>思路：但是用时比较抽象，题中字符都是小写字母，其实可以用桶排解决，还有就是滑动窗口其实只有头尾字符次数会变，可以用数组维护滑动窗口的字符出现个数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; findAnagrams(String s, String p) &#123;</span><br><span class="line">        if(s.length()&lt;p.length())&#123;</span><br><span class="line">            return new ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">        int[] pCnt = new int[26];</span><br><span class="line">        int[] sCnt = new int[26];</span><br><span class="line">        char[] pChars = p.toCharArray();</span><br><span class="line">        for(char pChar:pChars)&#123;</span><br><span class="line">            ++pCnt[pChar-&#x27;a&#x27;];</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i =0;i&lt;p.length();i++)&#123;</span><br><span class="line">            ++sCnt[s.charAt(i)-&#x27;a&#x27;];</span><br><span class="line">        &#125;</span><br><span class="line">        if(Arrays.equals(pCnt, sCnt))&#123;</span><br><span class="line">            ans.add(0);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i =0;i&lt;s.length()-p.length();i++)&#123;</span><br><span class="line">            --sCnt[s.charAt(i)-&#x27;a&#x27;];</span><br><span class="line">            ++sCnt[s.charAt(i+p.length())-&#x27;a&#x27;];</span><br><span class="line">            if(Arrays.equals(pCnt, sCnt))&#123;</span><br><span class="line">                ans.add(i+1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011246821.png" alt="image-20240201181858045"></p>
<p>继续优化，每次都要整个数组遍历一遍比较太浪费时间，所以维护一个变长滑动窗口，当窗口长度跟p的长度相同时符合条件，这样就不用每次都比较数组相等了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; findAnagrams(String s, String p) &#123;</span><br><span class="line">        if(s.length()&lt;p.length())&#123;</span><br><span class="line">            return new ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        int[] cnt = new int[26];</span><br><span class="line">        int fast=0,slow=0;</span><br><span class="line">        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">        for(char ch:p.toCharArray())&#123;</span><br><span class="line">            ++cnt[ch-&#x27;a&#x27;];</span><br><span class="line">        &#125;</span><br><span class="line">        while(fast&lt;s.length())&#123;</span><br><span class="line">            if(cnt[s.charAt(fast)-&#x27;a&#x27;]&gt;0)&#123;</span><br><span class="line">                --cnt[s.charAt(fast++)-&#x27;a&#x27;];</span><br><span class="line">                if(fast-slow==p.length())&#123;</span><br><span class="line">                    ans.add(slow);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                ++cnt[s.charAt(slow++)-&#x27;a&#x27;];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011246956.png" alt="image-20240201190210868"></p>
<h2 id="3-2两个数组的交集"><a href="#3-2两个数组的交集" class="headerlink" title="3.2两个数组的交集"></a>3.2两个数组的交集</h2><h3 id="3-2-1两个数组的交集"><a href="#3-2-1两个数组的交集" class="headerlink" title="3.2.1两个数组的交集"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-arrays/">3.2.1两个数组的交集</a></h3><p>思路：将一个数组的元素放在一个set中自动去重，然后遍历另一个数组，找到前一个集合中出现过的元素即为交集</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] intersection(int[] nums1, int[] nums2) &#123;</span><br><span class="line">        Set&lt;Integer&gt; union1 = new HashSet&lt;&gt;();</span><br><span class="line">        Set&lt;Integer&gt; union = new HashSet&lt;&gt;();</span><br><span class="line">        for(int num:nums1)&#123;</span><br><span class="line">            union1.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int num:nums2)&#123;</span><br><span class="line">            if(union1.contains(num))&#123;</span><br><span class="line">                union.add(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return union.stream().mapToInt(Integer::intValue).toArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011246884.png" alt="image-20240201201446411"></p>
<h3 id="3-2-2两个数组的交集Ⅱ"><a href="#3-2-2两个数组的交集Ⅱ" class="headerlink" title="3.2.2两个数组的交集Ⅱ"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-arrays-ii/">3.2.2两个数组的交集Ⅱ</a></h3><p>思路：跟上题差不多，不过是用HsahMap记录了每个数的出现次数，然后转换成int[]</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] intersect(int[] nums1, int[] nums2) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">        for(int num:nums1)&#123;</span><br><span class="line">            map.put(num, map.getOrDefault(num,0)+1);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int num:nums2)&#123;</span><br><span class="line">            if(map.getOrDefault(num,0)&gt;0)&#123;</span><br><span class="line">                ans.add(num);</span><br><span class="line">                map.put(num,map.get(num)-1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int[] a = new int[ans.size()];</span><br><span class="line">        for(int i =0;i&lt;ans.size();i++)&#123;</span><br><span class="line">            a[i]=ans.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011246793.png" alt="image-20240201205851761"></p>
<h2 id="3-3快乐数"><a href="#3-3快乐数" class="headerlink" title="3.3快乐数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/happy-number/">3.3快乐数</a></h2><p>思路：主要就是判断什么时候要继续循环直到平方和等于1，什么时候可以判断继续循环下去不能得到1，判断n为快乐数的条件显然易得，但是什么时候可以确定n不是快乐数呢，题目中提到了会无限循环，是不是说明如果非快乐数平方和相加的结果是一个循环呢，尝试了一下结果真的可以</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isHappy(int n) &#123;</span><br><span class="line">        int sum=0;</span><br><span class="line">        int s=0;</span><br><span class="line">        Set&lt;Integer&gt; set = new HashSet&lt;&gt;();</span><br><span class="line">        set.add(n);</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            while(n&gt;0)&#123;</span><br><span class="line">                s=n%10;</span><br><span class="line">                n/=10;</span><br><span class="line">                sum+=s*s;</span><br><span class="line">            &#125;</span><br><span class="line">            if(sum==1)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if(set.contains(sum))&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(sum);</span><br><span class="line">            n=sum;</span><br><span class="line">            sum=0;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011246889.png" alt="image-20240201215909152"></p>
<p>看看题解，数组不断平方和会有三种结果</p>
<ol>
<li>最终得到1</li>
<li>最终进入循环</li>
<li>值越来越大，最后接近无穷</li>
</ol>
<p>但是第三个结果不太可能，官方题解是这么说的</p>
<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011246092.png" alt="image-20240201220703272"></p>
<p>即使是十三位数的最大值的平方和也才到1053，所以第三种情况是不可能出现的，所以非快乐数只有平方和陷入循环的情况</p>
<h2 id="3-4两数之和"><a href="#3-4两数之和" class="headerlink" title="3.4两数之和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum/">3.4两数之和</a></h2><p>思路：首先非常容易想到的就是双重循环，实现起来也很简单，但是用时比较长</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">        for(int i=0;i&lt;nums.length;i++)&#123;</span><br><span class="line">            for(int j=i+1;j&lt;nums.length;j++)&#123;</span><br><span class="line">                if(nums[i]+nums[j]==target)&#123;</span><br><span class="line">                    return new int[]&#123;i,j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return new int[2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011246644.png" alt="image-20240201221652807"></p>
<p>怎么优化呢，题目中是要在数组中找到两个数相加等于target，那么如果有一个数num是这题的答案，那么就要在数组中找到另一个数等于target-num，对于这种是否存在的问题可以使用哈希的方式快速确定</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        for(int i = 0;i&lt;nums.length;i++)&#123;</span><br><span class="line">            if(map.containsKey(target-nums[i]))&#123;</span><br><span class="line">                return new int[]&#123;map.get(target-nums[i]),i&#125;;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                map.put(nums[i],i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return new int[2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011246806.png" alt="image-20240201222719952"></p>
<h2 id="3-5四数相加"><a href="#3-5四数相加" class="headerlink" title="3.5四数相加"></a>3.5四数相加</h2><h3 id="3-5-1四数相加Ⅱ"><a href="#3-5-1四数相加Ⅱ" class="headerlink" title="3.5.1四数相加Ⅱ"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/4sum-ii/">3.5.1四数相加Ⅱ</a></h3><p>思路：最简单自然想到的肯定还是四重循环遍历，但是有了上题的铺垫，我们想一下有什么办法可以优化呢。上题是用HashMap记录了已经出现的数和对应的索引，从O(n^2)优化到了O(n)，现在从四个数组找相加等于0，那么我们可以仿照上题的思路，将四数分为两组，用HashMap记录一组数据相加的全部和，然后计算另一组的和，从HashMap中找到另一组中是否存在和的相反数，为了尽可能的降低时间复杂度，我们可以两两一组，这样两组计算和的时间复杂度都是O(n^2)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        int res=0;</span><br><span class="line">        for(int i=0;i&lt;nums1.length;i++)&#123;</span><br><span class="line">            for(int j=0;j&lt;nums2.length;j++)&#123;</span><br><span class="line">                int sum1 = nums1[i]+nums2[j];</span><br><span class="line">                map.put(sum1,map.getOrDefault(sum1,0)+1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;nums3.length;i++)&#123;</span><br><span class="line">            for(int j=0;j&lt;nums4.length;j++)&#123;</span><br><span class="line">                res+=map.getOrDefault(-nums3[i]-nums4[j],0);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011246465.png" alt="image-20240201230052768"></p>
<h3 id="3-5-2三数之和"><a href="#3-5-2三数之和" class="headerlink" title="3.5.2三数之和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/3sum/">3.5.2三数之和</a></h3><p>思路：这题有点复杂，最先想到的还是暴力遍历，三重循环然后用set去重</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;</span><br><span class="line">        Set&lt;List&lt;Integer&gt;&gt; ans = new HashSet&lt;&gt;();</span><br><span class="line">        for(int i =0;i&lt;nums.length;i++)&#123;</span><br><span class="line">            for(int j=i+1;j&lt;nums.length;j++)&#123;</span><br><span class="line">                if(i==j)&#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                for(int k=j+1;k&lt;nums.length;k++)&#123;</span><br><span class="line">                    if(i==k||j==k)&#123;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if(nums[i]+nums[j]+nums[k]==0)&#123;</span><br><span class="line">                        List&lt;Integer&gt; sum = new ArrayList&lt;&gt;();</span><br><span class="line">                        sum.add(nums[i]);</span><br><span class="line">                        sum.add(nums[j]);</span><br><span class="line">                        sum.add(nums[k]);</span><br><span class="line">                        sum.sort((a,b)-&gt;a-b);</span><br><span class="line">                        ans.add(sum);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return new ArrayList&lt;List&lt;Integer&gt;&gt;(ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011246755.png" alt="image-20240201234339884"></p>
<p>三重循环O(n^3)毫无意外的超时了，那么有什么办法可以优化呢，这种相加问题很容易就想到要用哈希表去寻找，但是在这题不太适用，哈希表不能很好的解决去重的问题，后来看了其他人的思路，大概就是可以先排序数组，然后遍历数组，固定一个节点，然后双指针从头尾开始往中间逼近寻找，这样的时间复杂度在O(n^2)，比上面的用时要少</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        Set&lt;List&lt;Integer&gt;&gt; set = new HashSet&lt;&gt;();</span><br><span class="line">        int left,right;</span><br><span class="line">        for(int i=0;i&lt;nums.length-2;i++)&#123;</span><br><span class="line">            left=i+1;</span><br><span class="line">            right=nums.length-1;</span><br><span class="line">            while(left&lt;right)&#123;</span><br><span class="line">                int sum=nums[i]+nums[left]+nums[right];</span><br><span class="line">                if(sum==0)&#123;</span><br><span class="line">                    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">                    list.add(nums[i]);</span><br><span class="line">                    list.add(nums[left]);</span><br><span class="line">                    list.add(nums[right]);</span><br><span class="line">                    set.add(list);</span><br><span class="line">                    --right;</span><br><span class="line">                    ++left;</span><br><span class="line">                &#125;else if (sum&gt;0)&#123;</span><br><span class="line">                    --right;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    ++left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return new ArrayList&lt;List&lt;Integer&gt;&gt;(set);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011246111.png" alt="image-20240202002649069"></p>
<p>但是这种做法耗时好像还是比较久，那么有什么办法可以更快呢，这里可以做一些简单的优化，如果是相同的元素可以加一层循环直接跳过，这样也不用Set去重，最后还要转回List</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">        int left,right;</span><br><span class="line">        for(int i=0;i&lt;nums.length-2;i++)&#123;</span><br><span class="line">            if(i&gt;0&amp;&amp;nums[i]==nums[i-1])&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            left=i+1;</span><br><span class="line">            right=nums.length-1;</span><br><span class="line">            while(left&lt;right)&#123;</span><br><span class="line">                int sum=nums[i]+nums[left]+nums[right];</span><br><span class="line">                if(sum==0)&#123;</span><br><span class="line">                    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">                    list.add(nums[i]);</span><br><span class="line">                    list.add(nums[left]);</span><br><span class="line">                    list.add(nums[right]);</span><br><span class="line">                    ans.add(list);</span><br><span class="line">                    do&#123;</span><br><span class="line">                        --right;</span><br><span class="line">                    &#125;while(nums[right]==nums[right+1]&amp;&amp;left&lt;right);</span><br><span class="line">                    do&#123;</span><br><span class="line">                        ++left;</span><br><span class="line">                    &#125;while(nums[left]==nums[left-1]&amp;&amp;left&lt;right);</span><br><span class="line">                &#125;else if (sum&gt;0)&#123;</span><br><span class="line">                    do&#123;</span><br><span class="line">                        --right;</span><br><span class="line">                    &#125;while(nums[right]==nums[right+1]&amp;&amp;left&lt;right);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    do&#123;</span><br><span class="line">                        ++left;</span><br><span class="line">                    &#125;while(nums[left]==nums[left-1]&amp;&amp;left&lt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011246826.png" alt="image-20240202122516472"></p>
<p>可以看到耗时大幅的减少，由此可见样例给出的重复元素还是挺多的，然后再看一下其他人的解，发现一个跳出循环的判断，当最小的指针大于0的时候，三个数的和一定大于零，加上这个特判之后，用时又减少了</p>
<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011246409.png" alt="image-20240202123405802"></p>
<p>但是其实最后两个优化并没有从时间复杂度上优化，但是在这道题的样例点还是能优化不少时间的，最难想的还是这个排序后用固定一个点然后双指针遍历</p>
<h3 id="3-5-3四数之和"><a href="#3-5-3四数之和" class="headerlink" title="3.5.3四数之和"></a><a target="_blank" rel="noopener" href="https://programmercarl.com/0018.%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C.html">3.5.3四数之和</a></h3><p>思路：这题跟上题差不多，只是多了一个数多了一层循环</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">        int left,right;</span><br><span class="line">        long sum=0;</span><br><span class="line">        for(int i =0;i&lt;nums.length-3;i++)&#123;</span><br><span class="line">            if(i&gt;0&amp;&amp;nums[i]==nums[i-1])&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if(nums[i]&gt;0&amp;&amp;nums[i]&gt;target)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int j=i+1;j&lt;nums.length-2;j++)&#123;</span><br><span class="line">                if(j&gt;i+1&amp;&amp;nums[j]==nums[j-1])&#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if(nums[i]+nums[j]&gt;0&amp;&amp;nums[i]+nums[j]&gt;target)&#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                left=j+1;</span><br><span class="line">                right=nums.length-1;</span><br><span class="line">                while(left&lt;right)&#123;</span><br><span class="line">                    sum=(long)nums[i]+nums[j]+nums[left]+nums[right];</span><br><span class="line">                    if(sum==target)&#123;</span><br><span class="line">                        ans.add(new ArrayList&lt;&gt;(Arrays.asList(nums[i],nums[j],nums[left],nums[right])));</span><br><span class="line">                        do&#123;</span><br><span class="line">                            ++left;</span><br><span class="line">                        &#125;while(nums[left]==nums[left-1]&amp;&amp;left&lt;right);</span><br><span class="line">                        do&#123;</span><br><span class="line">                            --right;</span><br><span class="line">                        &#125;while(nums[right]==nums[right+1]&amp;&amp;left&lt;right);</span><br><span class="line">                    &#125;else if(sum&gt;target)&#123;</span><br><span class="line">                        do&#123;</span><br><span class="line">                            --right;</span><br><span class="line">                        &#125;while(nums[right]==nums[right+1]&amp;&amp;left&lt;right);</span><br><span class="line">                    &#125;else&#123;</span><br><span class="line">                        do&#123;</span><br><span class="line">                            ++left;</span><br><span class="line">                        &#125;while(nums[left]==nums[left-1]&amp;&amp;left&lt;right);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011247316.png" alt="image-20240202130923936"></p>
<p>看了题解，方法其实都是一致的，只是在剪枝上做了优化，在官方给出的样例中能够更快的通过</p>
<h3 id="最接近的三数之和"><a href="#最接近的三数之和" class="headerlink" title="最接近的三数之和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/3sum-closest/description/">最接近的三数之和</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int threeSumClosest(int[] nums, int target) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        int res = nums[0]+nums[1]+nums[2];</span><br><span class="line">        int left,right;</span><br><span class="line">        for(int i=0;i&lt;nums.length-2;++i)&#123;</span><br><span class="line">            left=i+1;</span><br><span class="line">            right=nums.length-1;</span><br><span class="line">            while(left&lt;right)&#123;</span><br><span class="line">                int sum = nums[i]+nums[left]+nums[right];</span><br><span class="line">                if(sum&gt;target)&#123;</span><br><span class="line">                    if(Math.abs(res-target)&gt;Math.abs(sum-target))&#123;</span><br><span class="line">                        res = sum;</span><br><span class="line">                    &#125;</span><br><span class="line">                    do&#123;</span><br><span class="line">                        --right;</span><br><span class="line">                    &#125;while(left&lt;right&amp;&amp;nums[right]==nums[right+1]);</span><br><span class="line">                &#125;else if(sum&lt;target)&#123;</span><br><span class="line">                    if(Math.abs(res-target)&gt;Math.abs(sum-target))&#123;</span><br><span class="line">                        res = sum;</span><br><span class="line">                    &#125;</span><br><span class="line">                    do&#123;</span><br><span class="line">                        ++left;</span><br><span class="line">                    &#125;while(left&lt;right&amp;&amp;nums[left]==nums[left-1]);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    return sum;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://qgstudio2024.oss-cn-guangzhou.aliyuncs.com/pic/202409150908937.png" alt="image-20240915090817743"></p>
<h1 id="4-字符串"><a href="#4-字符串" class="headerlink" title="4.字符串"></a>4.字符串</h1><h2 id="4-1反转字符串"><a href="#4-1反转字符串" class="headerlink" title="4.1反转字符串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-string/">4.1反转字符串</a></h2><p>思路：很简单的一个循环交换</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void reverseString(char[] s) &#123;</span><br><span class="line">        int left=0;</span><br><span class="line">        int right=s.length-1;</span><br><span class="line">        char tem;</span><br><span class="line">        while(left&lt;right)&#123;</span><br><span class="line">            tem=s[left];</span><br><span class="line">            s[left++]=s[right];</span><br><span class="line">            s[right--]=tem;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011247570.png" alt="image-20240202134627532"></p>
<p>也可以用 ^ 运算计算值，主要是利用了 a^b^a&#x3D;b这个式子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void reverseString(char[] s) &#123;</span><br><span class="line">        int left=0;</span><br><span class="line">        int right=s.length-1;</span><br><span class="line">        char tem;</span><br><span class="line">        while(left&lt;right)&#123;</span><br><span class="line">            s[left]^=s[right];</span><br><span class="line">            s[right]^=s[left];</span><br><span class="line">            s[left++]^=s[right--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-2反转字符串Ⅱ"><a href="#4-2反转字符串Ⅱ" class="headerlink" title="4.2反转字符串Ⅱ"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-string-ii/">4.2反转字符串Ⅱ</a></h2><p>思路：题目虽然看着很复杂，但是还是很容易看出模型的，就是把字符串k个反转，然后跳过k个不断循环</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String reverseStr(String s, int k) &#123;</span><br><span class="line">        char[]sChar = s.toCharArray();</span><br><span class="line">        int cnt=0;</span><br><span class="line">        while(cnt*k&lt;=s.length())&#123;</span><br><span class="line">            reverseString(sChar,cnt*k,Math.min((cnt+1)*k,s.length())-1);</span><br><span class="line">            cnt+=2;</span><br><span class="line">        &#125;</span><br><span class="line">        return new String(sChar);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void reverseString(char[] s,int left,int right) &#123;</span><br><span class="line">        while(left&lt;right)&#123;</span><br><span class="line">            s[left]^=s[right];</span><br><span class="line">            s[right]^=s[left];</span><br><span class="line">            s[left++]^=s[right--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011247641.png" alt="image-20240202140120546"></p>
<h2 id="4-3翻转字符串的单词"><a href="#4-3翻转字符串的单词" class="headerlink" title="4.3翻转字符串的单词"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-words-in-a-string/">4.3翻转字符串的单词</a></h2><p>思路：这题用trim和split函数做出来挺简单的，但是在不使用这些函数的情况下要处理这些边界问题还是比较麻烦的，这里主要是用一个List把空格存取来，还要判断什么时候应该要存空格</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String reverseWords(String s) &#123;</span><br><span class="line">        char[] sChar = s.toCharArray();</span><br><span class="line">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        list.add(-1);</span><br><span class="line">        for(int i=0;i&lt;s.length();i++)&#123;</span><br><span class="line">            if(s.charAt(i)==&#x27; &#x27;)&#123;</span><br><span class="line">                list.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(s.length());</span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        boolean first = true;</span><br><span class="line">        boolean flag = false;</span><br><span class="line">        for(int i=list.size()-1;i&gt;0;i--)&#123;</span><br><span class="line">            for(int j=list.get(i-1)+1;j&lt;list.get(i);j++)&#123;</span><br><span class="line">                if(!first&amp;&amp;flag)&#123;</span><br><span class="line">                    sb.append(&quot; &quot;);</span><br><span class="line">                    flag=false;</span><br><span class="line">                &#125;</span><br><span class="line">                first=false;</span><br><span class="line">                sb.append(s.charAt(j));</span><br><span class="line">            &#125;</span><br><span class="line">            if(!first)&#123;</span><br><span class="line">                flag=true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路二：先总体反转再单词反转</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String reverseWords(String s) &#123;</span><br><span class="line">        char[] trims = s.trim().toCharArray();</span><br><span class="line">        int slow=0;</span><br><span class="line">        for(int i=0;i&lt;trims.length;++i)&#123;</span><br><span class="line">            if(trims[i]!=&#x27; &#x27;)&#123;</span><br><span class="line">                trims[slow++]=trims[i];</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                while(trims[i+1]==&#x27; &#x27;)&#123;</span><br><span class="line">                    ++i;</span><br><span class="line">                &#125;</span><br><span class="line">                trims[slow++]=&#x27; &#x27;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        reverseCharArray(trims,0,slow-1);</span><br><span class="line">        reverWords(trims,0,slow-1);</span><br><span class="line"></span><br><span class="line">        return new String(trims).substring(0,slow);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void reverWords(char[] words, int left, int right)&#123;</span><br><span class="line">        int virtual = left;</span><br><span class="line">        while(virtual&lt;right)&#123;</span><br><span class="line">            while(virtual&lt;right &amp;&amp; words[virtual+1]!=&#x27; &#x27;)&#123;</span><br><span class="line">                ++virtual;</span><br><span class="line">            &#125;</span><br><span class="line">            reverseCharArray(words,left,virtual);</span><br><span class="line">            left=virtual+2;</span><br><span class="line">            ++virtual;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void reverseCharArray(char[] chars, int left, int right)&#123;</span><br><span class="line">        while(left&lt;right)&#123;</span><br><span class="line">            char tem = chars[left];</span><br><span class="line">            chars[left]=chars[right];</span><br><span class="line">            chars[right]=tem;</span><br><span class="line">            ++left;</span><br><span class="line">            --right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-4旋转字符串"><a href="#4-4旋转字符串" class="headerlink" title="4.4旋转字符串"></a>4.4旋转字符串</h2><h3 id="4-4-1右旋转字符串"><a href="#4-4-1右旋转字符串" class="headerlink" title="4.4.1右旋转字符串"></a><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1065">4.4.1右旋转字符串</a></h3><p>思路：字符串拼接分开拼接一下就好了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line">        int k = scanner.nextInt();</span><br><span class="line">        String next = scanner.next();</span><br><span class="line">        System.out.println(next.substring(next.length()-k)+next.substring(0,next.length()-k));</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-5实现strStr"><a href="#4-5实现strStr" class="headerlink" title="*4.5实现strStr()"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">*4.5实现strStr()</a></h2><p>思路：不使用index函数的情况下，最容易想到的还是暴力循环</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int strStr(String haystack, String needle) &#123;</span><br><span class="line">        for(int i=0;i&lt;haystack.length();i++)&#123;</span><br><span class="line">            int index=0;</span><br><span class="line">            while(i+index&lt;haystack.length()&amp;&amp;</span><br><span class="line">                index&lt;needle.length()&amp;&amp;</span><br><span class="line">                haystack.charAt(i+index)==needle.charAt(index))&#123;</span><br><span class="line">                    ++index;</span><br><span class="line">            &#125;</span><br><span class="line">            if(index==needle.length())&#123;</span><br><span class="line">                return i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011247771.png" alt="image-20240202165704518"></p>
<p>但是这题其实还可以用KMP算法来解决，KMP的特点就是当出现字符串不匹配的情况可以不用从头匹配，只需要一次循环就能够找到字串，那么他是怎么做到的呢，下面介绍一下KMP算法</p>
<p>KMP算法的核心思想就是：当字符串出现不匹配的时候，会有一个数组（记作next）告诉你，可以从字串的哪个位置（记作i）继续往后匹配，避免从头再去匹配，因为next保证了字串的开头前next[i]个字符和从i往前数next[i]个字符是一样的，这个数组称为前缀表，主要的作用就是字符不匹配的时候进行回退</p>
<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011248256.gif" alt="KMP精讲4"></p>
<p>上图中当文本串指针到达第二个b的时候，模式串是f，跟文本串不一致，这时候模式串的指针只需要回到第一个b的位置就可以和文本串的指针继续往后匹配了，因为模式串的开头aa出现了两次，第二个aa跟模式串的前缀aa是一样的，指针在f说明前面已经出现过了aa，所以这个时候模式串的指针只需要从b开始比较就可以了，而不需要从头开始，文本串也不需要往前回溯，这样比较的时间复杂度就成了O(n)</p>
<p>前缀表的构成分为三个部分：</p>
<ol>
<li>初始化</li>
<li>处理前后缀不相同的情况</li>
<li>处理前后缀相同的情况</li>
</ol>
<p>下面是实现代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public int[] getNext(String s)&#123;</span><br><span class="line">        //初始化</span><br><span class="line">        int[] next = new int[s.length()];</span><br><span class="line">        int j =-1;</span><br><span class="line">        next[0]=j;</span><br><span class="line">        for(int i=1;i&lt;s.length();i++)&#123;</span><br><span class="line">            //处理前后缀不相同情况</span><br><span class="line">            while(j&gt;=0&amp;&amp;s.charAt(i)!=s.charAt(j+1))&#123;</span><br><span class="line">                j=next[j];</span><br><span class="line">            &#125;</span><br><span class="line">            //处理前后缀相同情况</span><br><span class="line">            if(s.charAt(i)==s.charAt(j+1))&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i]=j;</span><br><span class="line">        &#125;</span><br><span class="line">        return next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>那么这道题目的答案也就出来了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int strStr(String haystack, String needle) &#123;</span><br><span class="line">        int[]next = getNext(needle);</span><br><span class="line">        int j=-1;</span><br><span class="line">        for(int i=0;i&lt;haystack.length();i++)&#123;</span><br><span class="line">            while(j&gt;=0&amp;&amp;needle.charAt(j+1)!=haystack.charAt(i))&#123;</span><br><span class="line">                j=next[j];</span><br><span class="line">            &#125;</span><br><span class="line">            if(haystack.charAt(i)==needle.charAt(j+1))&#123;</span><br><span class="line">                j++;</span><br><span class="line">                if(j==needle.length()-1)&#123;</span><br><span class="line">                    return i-j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int[] getNext(String s)&#123;</span><br><span class="line">        //初始化</span><br><span class="line">        int[] next = new int[s.length()];</span><br><span class="line">        int j =-1;</span><br><span class="line">        next[0]=j;</span><br><span class="line">        for(int i=1;i&lt;s.length();i++)&#123;</span><br><span class="line">            //处理前后缀不相同情况</span><br><span class="line">            while(j&gt;=0&amp;&amp;s.charAt(i)!=s.charAt(j+1))&#123;</span><br><span class="line">                j=next[j];</span><br><span class="line">            &#125;</span><br><span class="line">            //处理前后缀相同情况</span><br><span class="line">            if(s.charAt(i)==s.charAt(j+1))&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i]=j;</span><br><span class="line">        &#125;</span><br><span class="line">        return next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011248876.png" alt="image-20240202222446397"></p>
<h2 id="4-6重复的子字符串"><a href="#4-6重复的子字符串" class="headerlink" title="*4.6重复的子字符串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/repeated-substring-pattern/">*4.6重复的子字符串</a></h2><p>思路1：这题可以用暴力求解，注意一些细节的处理就好了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean repeatedSubstringPattern(String s) &#123;</span><br><span class="line">        for(int i =1;i&lt;s.length()/2;i++)&#123;</span><br><span class="line">            if(s.length()%i!=0)&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            boolean flag=true;</span><br><span class="line">            for(int j=i;j&lt;s.length();j++)&#123;</span><br><span class="line">                if(s.charAt(j)!=s.charAt(j-i))&#123;</span><br><span class="line">                    flag=false;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(flag)&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011248389.png" alt="image-20240202235638971"></p>
<p>思路2：如果s是重复的子字符串，那么s+s去掉头尾后应该还存在一个s</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean repeatedSubstringPattern(String s) &#123;</span><br><span class="line">        String newString=s+s;</span><br><span class="line">        newString=newString.substring(1,newString.length()-1);</span><br><span class="line">        if(newString.indexOf(s)!=-1)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路3：KMP算法就是用来寻找重复字串的，放在这题正好可以判断，如果s可以由多个字串构成，那么最后一个字符跟回退索引的差就是字串长度，他应该是s长度的公因数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean repeatedSubstringPattern(String s) &#123;</span><br><span class="line">        int[] next = new int[s.length()];</span><br><span class="line">        int j =-1;</span><br><span class="line">        next[0]=j;</span><br><span class="line">        for(int i=1;i&lt;s.length();i++)&#123;</span><br><span class="line">            //处理前后缀不相同情况</span><br><span class="line">            while(j&gt;=0&amp;&amp;s.charAt(i)!=s.charAt(j+1))&#123;</span><br><span class="line">                j=next[j];</span><br><span class="line">            &#125;</span><br><span class="line">            //处理前后缀相同情况</span><br><span class="line">            if(s.charAt(i)==s.charAt(j+1))&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i]=j;</span><br><span class="line">        &#125;</span><br><span class="line">        if(next[s.length()-1]!=-1&amp;&amp;s.length()%(s.length()-next[s.length()-1]-1)==0)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011248480.png" alt="image-20240203001703573"></p>
<h1 id="5-双指针法"><a href="#5-双指针法" class="headerlink" title="5.双指针法"></a>5.双指针法</h1><h2 id="比较版本号"><a href="#比较版本号" class="headerlink" title="比较版本号"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/compare-version-numbers">比较版本号</a></h2><p>思路1：直接split，但是注意转义字符  .</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int compareVersion(String version1, String version2) &#123;</span><br><span class="line">        </span><br><span class="line">        String[] v1 = version1.split(&quot;\\.&quot;);</span><br><span class="line">        String[] v2 = version2.split(&quot;\\.&quot;);</span><br><span class="line">        for(int i=0;i&lt;v1.length||i&lt;v2.length;++i)&#123;</span><br><span class="line">            int n1=0;</span><br><span class="line">            int n2=0;</span><br><span class="line">            if(i&lt;v2.length)&#123;</span><br><span class="line">                n2=Integer.parseInt(v2[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            if(i&lt;v1.length)&#123;</span><br><span class="line">                n1=Integer.parseInt(v1[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            if(n1&gt;n2)&#123;</span><br><span class="line">                return 1;</span><br><span class="line">            &#125;else if(n1&lt;n2)&#123;</span><br><span class="line">                return -1;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路2：双指针</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int compareVersion(String version1, String version2) &#123;</span><br><span class="line">        int p1 = 0;</span><br><span class="line">        int p2 = 0;</span><br><span class="line">        while(p1&lt;version1.length()&amp;&amp;p2&lt;version2.length())&#123;</span><br><span class="line">            int v1=p1+1;</span><br><span class="line">            int v2=p2+1;</span><br><span class="line">            while(v1&lt;version1.length()&amp;&amp;version1.charAt(v1)!=&#x27;.&#x27;)&#123;</span><br><span class="line">                ++v1;</span><br><span class="line">            &#125;</span><br><span class="line">            while(v2&lt;version2.length()&amp;&amp;version2.charAt(v2)!=&#x27;.&#x27;)&#123;</span><br><span class="line">                ++v2;</span><br><span class="line">            &#125;</span><br><span class="line">            int n1=Integer.parseInt(version1.substring(p1,v1));</span><br><span class="line">            int n2=Integer.parseInt(version2.substring(p2,v2));</span><br><span class="line">            if(n1&gt;n2)&#123;</span><br><span class="line">                return 1;</span><br><span class="line">            &#125;else if(n2&gt;n1)&#123;</span><br><span class="line">                return -1;</span><br><span class="line">            &#125;</span><br><span class="line">            p1=v1+1;</span><br><span class="line">            p2=v2+1;</span><br><span class="line">        &#125;</span><br><span class="line">        if(p1&lt;version1.length())&#123;</span><br><span class="line">            while(p1&lt;version1.length())&#123;</span><br><span class="line">                int v1=p1+1;</span><br><span class="line">                while(v1&lt;version1.length()&amp;&amp;version1.charAt(v1)!=&#x27;.&#x27;)&#123;</span><br><span class="line">                    ++v1;</span><br><span class="line">                &#125;</span><br><span class="line">                int n1=Integer.parseInt(version1.substring(p1,v1));</span><br><span class="line">                if(n1&gt;0)&#123;</span><br><span class="line">                    return 1;</span><br><span class="line">                &#125;</span><br><span class="line">                p1=v1+1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else if(p2&lt;version2.length())&#123;</span><br><span class="line">            while(p2&lt;version2.length())&#123;</span><br><span class="line">                int v2=p2+1;</span><br><span class="line">                while(v2&lt;version2.length()&amp;&amp;version2.charAt(v2)!=&#x27;.&#x27;)&#123;</span><br><span class="line">                    ++v2;</span><br><span class="line">                &#125;</span><br><span class="line">                int n2=Integer.parseInt(version2.substring(p2,v2));</span><br><span class="line">                if(n2&gt;0)&#123;</span><br><span class="line">                    return -1;</span><br><span class="line">                &#125;</span><br><span class="line">                p2=v2+1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="6-栈和队列"><a href="#6-栈和队列" class="headerlink" title="6.栈和队列"></a>6.栈和队列</h1><h2 id="6-1用栈实现队列"><a href="#6-1用栈实现队列" class="headerlink" title="6.1用栈实现队列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-queue-using-stacks/">6.1用栈实现队列</a></h2><p>思路：用两个栈实现，栈的特点是后进先出，队列的特点是先进先出，每次插入元素的时候把栈中的元素存到另一个栈，然后插入元素使其落入栈底，然后按顺序把原来的元素入栈即可维持一条队列</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class MyQueue &#123;</span><br><span class="line"></span><br><span class="line">    Stack&lt;Integer&gt; stack1;</span><br><span class="line">    Stack&lt;Integer&gt; stack2;</span><br><span class="line">    int size;</span><br><span class="line"></span><br><span class="line">    public MyQueue() &#123;</span><br><span class="line">        this.stack1 = new Stack&lt;&gt;();</span><br><span class="line">        this.stack2 = new Stack&lt;&gt;();</span><br><span class="line">        this.size=0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void push(int x) &#123;</span><br><span class="line">        while(!stack2.empty())&#123;</span><br><span class="line">            stack1.push(stack2.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        stack2.push(x);</span><br><span class="line">        while(!stack1.empty())&#123;</span><br><span class="line">            stack2.push(stack1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int pop() &#123;</span><br><span class="line">        return stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int peek() &#123;</span><br><span class="line">        return stack2.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean empty() &#123;</span><br><span class="line">        return stack2.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011248759.png" alt="image-20240203204024533"></p>
<h1 id="7-二叉树"><a href="#7-二叉树" class="headerlink" title="7.二叉树"></a>7.二叉树</h1><h2 id="7-1前序遍历"><a href="#7-1前序遍历" class="headerlink" title="7.1前序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">7.1前序遍历</a></h2><p>思路：简单的递归，按照根节点，左子树，右子树的顺序遍历这棵树</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">    public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;</span><br><span class="line">        preTraversal(root);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    public void preTraversal(TreeNode root)&#123;</span><br><span class="line">        if(root==null)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.add(root.val);</span><br><span class="line">        preTraversal(root.left);</span><br><span class="line">        preTraversal(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011249552.png" alt="image-20240321110656975"></p>
<p>思路2：非递归，利用栈后进先出的特性，将根节点的左右子节点进栈</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        while(stack.size()&gt;0)&#123;</span><br><span class="line">            TreeNode now = stack.pop();</span><br><span class="line">            if(now != null)&#123;</span><br><span class="line">                ans.add(now.val);</span><br><span class="line">                stack.push(now.right);</span><br><span class="line">                stack.push(now.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011249347.png" alt="image-20240321111705329"></p>
<h2 id="7-2后序遍历"><a href="#7-2后序遍历" class="headerlink" title="7.2后序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">7.2后序遍历</a></h2><p>思路：递归，跟先序遍历的递归差不多，但是要注意遍历的顺序改变了。现在是根据左子树，右子树，根节点的数据遍历</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">    public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;</span><br><span class="line">        postTraversal(root);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    public void postTraversal(TreeNode root)&#123;</span><br><span class="line">        if(root==null)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        postTraversal(root.left);</span><br><span class="line">        postTraversal(root.right);</span><br><span class="line">        ans.add(root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011249883.png" alt="image-20240321112033556"></p>
<p>思路2：迭代，还是用一个栈维护先前的节点，然后按照左节点，右节点，根节点的顺序遍历</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        TreeNode pre= null;</span><br><span class="line">        while(root!=null || stack.size()&gt;0)&#123;</span><br><span class="line">            while(root!=null)&#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root=root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root=stack.pop();</span><br><span class="line">            if(root.right==null || pre==root.right)&#123;</span><br><span class="line">                ans.add(root.val);</span><br><span class="line">                pre=root;</span><br><span class="line">                root=null;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root=root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011249187.png" alt="image-20240321134520602"></p>
<h2 id="7-3中序遍历"><a href="#7-3中序遍历" class="headerlink" title="7.3中序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">7.3中序遍历</a></h2><p>思路：递归，还是跟上面两题的递归方法差不多，只需要改变遍历和访问节点的顺序即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;</span><br><span class="line">        midTraversal(root);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    public void midTraversal(TreeNode root)&#123;</span><br><span class="line">        if(root==null)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        midTraversal(root.left);</span><br><span class="line">        ans.add(root.val);</span><br><span class="line">        midTraversal(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011249465.png" alt="image-20240321135944809"></p>
<p>思路2：迭代，还是跟上面两题的迭代方法差不多，注意遍历的顺序是左节点，根节点，右节点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        while(root!=null || stack.size()&gt;0)&#123;</span><br><span class="line">            while(root!=null)&#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root=root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root=stack.pop();</span><br><span class="line">            ans.add(root.val);</span><br><span class="line">            root=root.right;</span><br><span class="line">        &#125;   </span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011249519.png" alt="image-20240321141030484"></p>
<h2 id="7-4层序遍历"><a href="#7-4层序遍历" class="headerlink" title="7.4层序遍历"></a>7.4层序遍历</h2><h3 id="7-4-1二叉树的层序遍历"><a href="#7-4-1二叉树的层序遍历" class="headerlink" title="7.4.1二叉树的层序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">7.4.1二叉树的层序遍历</a></h3><p>思路：可以用一个队列维护一层的元素，他的下一层元素就是改队列的每个节点的左右节点依次入队</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">        if(root==null)&#123;</span><br><span class="line">            return ans;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        while(queue.size()&gt;0)&#123;</span><br><span class="line">            List&lt;Integer&gt; level = new ArrayList&lt;&gt;();</span><br><span class="line">            for(int i=queue.size()-1;i&gt;=0;--i)&#123;</span><br><span class="line">                root = queue.poll();</span><br><span class="line">                level.add(root.val);</span><br><span class="line">                if(root.left!=null)&#123;</span><br><span class="line">                    queue.offer(root.left);</span><br><span class="line">                &#125;</span><br><span class="line">                if(root.right!=null)&#123;</span><br><span class="line">                    queue.offer(root.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.add(level);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011249039.png" alt="image-20240321163503908"></p>
<h3 id="7-4-2二叉树的层序遍历Ⅱ"><a href="#7-4-2二叉树的层序遍历Ⅱ" class="headerlink" title="7.4.2二叉树的层序遍历Ⅱ"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/">7.4.2二叉树的层序遍历Ⅱ</a></h3><p>思路：跟上题一样，只是每层插入的位置都是从头插入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">        if(root==null)&#123;</span><br><span class="line">            return ans;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        while(queue.size()&gt;0)&#123;</span><br><span class="line">            List&lt;Integer&gt; level = new ArrayList&lt;&gt;();</span><br><span class="line">            for(int i=queue.size()-1;i&gt;=0;--i)&#123;</span><br><span class="line">                root = queue.poll();</span><br><span class="line">                level.add(root.val);</span><br><span class="line">                if(root.left!=null)&#123;</span><br><span class="line">                    queue.offer(root.left);</span><br><span class="line">                &#125;</span><br><span class="line">                if(root.right!=null)&#123;</span><br><span class="line">                    queue.offer(root.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.add(0,level);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011249339.png" alt="image-20240321163804838"></p>
<h3 id="7-4-3二叉树的右视图"><a href="#7-4-3二叉树的右视图" class="headerlink" title="7.4.3二叉树的右视图"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-right-side-view/">7.4.3二叉树的右视图</a></h3><p>思路：广度优先搜索，将相同深度即同一层的节点放在队列中，每次都将队列中最后一个节点添加到链表中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; rightSideView(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">        if(root==null)&#123;</span><br><span class="line">            return ans;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        while(queue.size()&gt;0)&#123;</span><br><span class="line">            int level =0;</span><br><span class="line">            for(int i=queue.size()-1;i&gt;=0;--i)&#123;</span><br><span class="line">                root = queue.poll();</span><br><span class="line">                level= root.val;</span><br><span class="line">                if(root.left!=null)&#123;</span><br><span class="line">                    queue.offer(root.left);</span><br><span class="line">                &#125;</span><br><span class="line">                if(root.right!=null)&#123;</span><br><span class="line">                    queue.offer(root.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.add(level);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011249984.png" alt="image-20240321214840811"></p>
<p>思路2：深度优先搜索，从上到下，从右到左进行深度优先搜索，将同一深度第一个遍历到的添加到队列</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; rightSideView(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">        dfs(root,0,ans);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    public void dfs(TreeNode root, int depth, List&lt;Integer&gt; ans)&#123;</span><br><span class="line">        if(root==null)&#123;</span><br><span class="line">            return; </span><br><span class="line">        &#125;</span><br><span class="line">        if(ans.size()==depth)&#123;</span><br><span class="line">            ans.add(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        ++depth;</span><br><span class="line">        dfs(root.right,depth,ans);</span><br><span class="line">        dfs(root.left,depth,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011249348.png" alt="image-20240321225749109"></p>
<h3 id="7-4-4层平均值"><a href="#7-4-4层平均值" class="headerlink" title="7.4.4层平均值"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/">7.4.4层平均值</a></h3><p>思路：由于要算层平均值，所以一层一层的处理会简单很多，首先用广度优先搜索做</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Double&gt; averageOfLevels(TreeNode root) &#123;</span><br><span class="line">        List&lt;Double&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">        if(root==null)&#123;</span><br><span class="line">            return ans;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        while(queue.size()&gt;0)&#123;</span><br><span class="line">            int size = queue.size();</span><br><span class="line">            double sum=0;</span><br><span class="line">            for(int i=0;i&lt;size;++i)&#123;</span><br><span class="line">                root = queue.poll();</span><br><span class="line">                sum+=root.val;</span><br><span class="line">                if(root.left!=null)&#123;</span><br><span class="line">                    queue.offer(root.left);</span><br><span class="line">                &#125;</span><br><span class="line">                if(root.right!=null)&#123;</span><br><span class="line">                    queue.offer(root.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.add(sum/size);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路2：用深度优先搜索，用两个链表分别记录每一层的个数和节点之和，最后统一算出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">    public List&lt;Double&gt; averageOfLevels(TreeNode root) &#123;</span><br><span class="line">        List&lt;Double&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Double&gt; sum = new ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; size = new ArrayList&lt;&gt;();</span><br><span class="line">        dfs(root,0,sum,size);</span><br><span class="line">        for(int i=0;i&lt;sum.size();++i)&#123;</span><br><span class="line">            ans.add(sum.get(i)/size.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    public void dfs(TreeNode root, int depth,List&lt;Double&gt; sum,List&lt;Integer&gt; size)&#123;</span><br><span class="line">        if(root==null)&#123;</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line">        if(depth&lt;sum.size())&#123;</span><br><span class="line">            size.set(depth,size.get(depth)+1);</span><br><span class="line">            sum.set(depth,sum.get(depth)+root.val);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            size.add(1);</span><br><span class="line">            sum.add(1.0*root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        ++depth;</span><br><span class="line">        dfs(root.left,depth,sum,size);</span><br><span class="line">        dfs(root.right,depth,sum,size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011249038.png"></p>
<h3 id="7-4-4-N叉树的层序遍历"><a href="#7-4-4-N叉树的层序遍历" class="headerlink" title="7.4.4 N叉树的层序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/n-ary-tree-level-order-traversal/">7.4.4 N叉树的层序遍历</a></h3><p>思路：广度优先搜索，处理还是跟二叉树一样，将一层的节点依次入队，不过二叉树是左右节点依次入队，现在是list子节点依次入队</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">        if(root==null)&#123;</span><br><span class="line">            return ans;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        while(queue.size()&gt;0)&#123;</span><br><span class="line">            List&lt;Integer&gt; level = new ArrayList&lt;&gt;();</span><br><span class="line">            for(int i=queue.size();i&gt;0;--i)&#123;</span><br><span class="line">                root=queue.poll();</span><br><span class="line">                level.add(root.val);</span><br><span class="line">                if(root.children!=null)&#123;</span><br><span class="line">                    for(int j=0;j&lt;root.children.size();++j)&#123;</span><br><span class="line">                        queue.offer(root.children.get(j));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.add(level);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011249631.png" alt="image-20240322095702013"></p>
<p>思路2：深度优先搜索，具体做法跟上面的题目差不多</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">        dfs(root,0,ans);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    public void dfs(Node root, int depth, List&lt;List&lt;Integer&gt;&gt;ans)&#123;</span><br><span class="line">        if(root==null)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(depth&lt;ans.size())&#123;</span><br><span class="line">            ans.get(depth).add(root.val);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            List&lt;Integer&gt; level =new ArrayList&lt;&gt;();</span><br><span class="line">            level.add(root.val);</span><br><span class="line">            ans.add(level);</span><br><span class="line">        &#125;</span><br><span class="line">        ++depth;</span><br><span class="line">        for(int i=0;i&lt;root.children.size();++i)&#123;</span><br><span class="line">            dfs(root.children.get(i),depth,ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011249342.png" alt="image-20240322101506455"></p>
<h3 id="7-4-5-在每个树行中找最大值"><a href="#7-4-5-在每个树行中找最大值" class="headerlink" title="7.4.5 在每个树行中找最大值"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/">7.4.5 在每个树行中找最大值</a></h3><p>思路：广度优先搜索，找到每层元素的最大值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; largestValues(TreeNode root) &#123;</span><br><span class="line">        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">        if(root==null)&#123;</span><br><span class="line">            return ans;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        while(queue.size()&gt;0)&#123;</span><br><span class="line">            int level =Integer.MIN_VALUE;</span><br><span class="line">            for(int i=queue.size();i&gt;0;--i)&#123;</span><br><span class="line">                root = queue.poll();</span><br><span class="line">                level=Math.max(level, root.val);</span><br><span class="line">                if(root.left!=null)&#123;</span><br><span class="line">                    queue.offer(root.left);</span><br><span class="line">                &#125;</span><br><span class="line">                if(root.right!=null)&#123;</span><br><span class="line">                    queue.offer(root.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.add(level);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011249649.png" alt="image-20240322202922053"></p>
<p>思路2：深度优先搜索，用ArrayList的索引和值把层数和最大值映射起来</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; largestValues(TreeNode root) &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">        dfs(root,0,ans);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    public void dfs(TreeNode root, int depth, ArrayList&lt;Integer&gt;ans)&#123;</span><br><span class="line">        if(root==null)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(depth&lt;ans.size())&#123;</span><br><span class="line">            ans.set(depth,Math.max(root.val,ans.get(depth)));</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            ans.add(depth,root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        ++depth;</span><br><span class="line">        dfs(root.left,depth,ans);</span><br><span class="line">        dfs(root.right,depth,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011249005.png" alt="image-20240322204624753"></p>
<h3 id="7-4-6-填充每个节点的下一个右侧节点指针"><a href="#7-4-6-填充每个节点的下一个右侧节点指针" class="headerlink" title="7.4.6 填充每个节点的下一个右侧节点指针"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/">7.4.6 填充每个节点的下一个右侧节点指针</a></h3><p>思路：广度优先搜索，将同一层的节点依次放在队列中，同一层的节点中，上一个节点的next指向下一个节点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public Node connect(Node root) &#123;</span><br><span class="line">        if(root==null)&#123;</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        Node pre=null;</span><br><span class="line">        Node cur = null;</span><br><span class="line">        while(queue.size()&gt;0)&#123;</span><br><span class="line">            for(int i=queue.size();i&gt;0;--i)&#123;</span><br><span class="line">                cur=queue.poll();</span><br><span class="line">                if(pre!=null)&#123;</span><br><span class="line">                    pre.next=cur;</span><br><span class="line">                &#125;</span><br><span class="line">                pre=cur;</span><br><span class="line">                if(cur.left!=null)&#123;</span><br><span class="line">                    queue.offer(cur.left);</span><br><span class="line">                &#125;</span><br><span class="line">                if(cur.right!=null)&#123;</span><br><span class="line">                    queue.offer(cur.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            pre=null;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011249132.png" alt="image-20240323100426726"></p>
<p>思路2：迭代，首先分析一下题目，给出的二叉树是完全二叉树，所以一个节点的next只有两种情况</p>
<p>第一种情况：该节点是他的父节点的左子节点，那么他的next是他的父节点的右子节点</p>
<p>第二种情况：该节点是他的父节点的右子节点，那么他的next是他的父节点的next的左子节点</p>
<p>分析出这两种情况之后我们就可以利用已经构建好next的一层节点去构建下一层的next</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public Node connect(Node root) &#123;</span><br><span class="line">        if(root==null)&#123;</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line">        Node start= root;</span><br><span class="line">        while(start.left!=null)&#123;</span><br><span class="line">            Node cur = start;</span><br><span class="line">            while(cur!=null)&#123;</span><br><span class="line">                cur.left.next=cur.right;</span><br><span class="line">                if(cur.next!=null)&#123;</span><br><span class="line">                    cur.right.next=cur.next.left;</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            start=start.left;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011250947.png" alt="image-20240323102231741"></p>
<h3 id="7-4-7-填充每个节点的下一个右侧节点指针Ⅱ"><a href="#7-4-7-填充每个节点的下一个右侧节点指针Ⅱ" class="headerlink" title="7.4.7 填充每个节点的下一个右侧节点指针Ⅱ"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/">7.4.7 填充每个节点的下一个右侧节点指针Ⅱ</a></h3><p>思路1：这题跟上一题唯一的差别就是二叉树不一定是完全二叉树，所以上题的思路1也可以做出这一题，甚至代码都不用修改，因为上题的思路1使用队列存储每一层的非空节点，所以在非完全二叉树中也能找到他的下一个右侧节点</p>
<p>思路2：迭代，还是跟上题一样根据上层的结构构建下层的结构，但是本体不是完全二叉树，所以不能分为上题的两种情况，可以用三个指针分别记录下一层的开始节点，下一层构建好的最后一个节点和当前节点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public Node connect(Node root) &#123;</span><br><span class="line">        if(root==null)&#123;</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line">        Node pre= null;</span><br><span class="line">        Node cur = null;</span><br><span class="line">        Node start = root;</span><br><span class="line">        while(start!=null)&#123;</span><br><span class="line">            cur=start;</span><br><span class="line">            pre=null;</span><br><span class="line">            start=null;</span><br><span class="line">            while(cur!=null)&#123;</span><br><span class="line">                if(cur.left!=null)&#123;</span><br><span class="line">                    if(pre!=null)&#123;</span><br><span class="line">                        pre.next=cur.left;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if(start==null)&#123;</span><br><span class="line">                        start=cur.left;</span><br><span class="line">                    &#125;</span><br><span class="line">                    pre=cur.left;</span><br><span class="line">                &#125;</span><br><span class="line">                if(cur.right!=null)&#123;</span><br><span class="line">                    if(pre!=null)&#123;</span><br><span class="line">                        pre.next=cur.right;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if(start==null)&#123;</span><br><span class="line">                        start=cur.right;</span><br><span class="line">                    &#125;</span><br><span class="line">                    pre=cur.right;</span><br><span class="line">                &#125;</span><br><span class="line">                cur=cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011250650.png" alt="image-20240323111411437"></p>
<h3 id="7-4-8-二叉树的最大深度"><a href="#7-4-8-二叉树的最大深度" class="headerlink" title="7.4.8 二叉树的最大深度"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">7.4.8 二叉树的最大深度</a></h3><p>思路：深度优先搜索，如果我们知道了左子树和右子树的最大深度l和r，那么二叉树的最大深度为max（l，r）+1，而左子树和右子树的最大深度又可以以同样的方式进行计算，因此我们可以递归算出最大深度</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxDepth(TreeNode root) &#123;</span><br><span class="line">        if(root==null)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return Math.max(maxDepth(root.left),maxDepth(root.right))+1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011250106.png" alt="image-20240325094505353"></p>
<p>思路2：广度优先搜索，用一个变量记录当前遍历的最大层级，每次循环完一层之后+1，最后即可算出最大深度</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxDepth(TreeNode root) &#123;</span><br><span class="line">        if(root==null)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int depth=0;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        while(queue.size()&gt;0)&#123;</span><br><span class="line">            for(int i=queue.size();i&gt;0;--i)&#123;</span><br><span class="line">                root=queue.poll();</span><br><span class="line">                if(root.left!=null)&#123;</span><br><span class="line">                    queue.offer(root.left);</span><br><span class="line">                &#125;</span><br><span class="line">                if(root.right!=null)&#123;</span><br><span class="line">                    queue.offer(root.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++depth;</span><br><span class="line">        &#125;</span><br><span class="line">        return depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011250311.png" alt="image-20240325094842828"></p>
<h3 id="7-4-9-二叉树的最小深度"><a href="#7-4-9-二叉树的最小深度" class="headerlink" title="7.4.9 二叉树的最小深度"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">7.4.9 二叉树的最小深度</a></h3><p>思路：广度优先搜索，还是用一个变量记录当前遍历的层级，然后当一个节点的左右子节点都是空的时候即为最小叶子节点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int minDepth(TreeNode root) &#123;</span><br><span class="line">        if(root==null)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int depth=0;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        while(queue.size()&gt;0)&#123;</span><br><span class="line">            ++depth;</span><br><span class="line">            for(int i=queue.size();i&gt;0;--i)&#123;</span><br><span class="line">                root=queue.poll();</span><br><span class="line">                if(root.left==null&amp;&amp;root.right==null)&#123;</span><br><span class="line">                    return depth;</span><br><span class="line">                &#125;</span><br><span class="line">                if(root.left!=null)&#123;</span><br><span class="line">                    queue.offer(root.left);</span><br><span class="line">                &#125;</span><br><span class="line">                if(root.right!=null)&#123;</span><br><span class="line">                    queue.offer(root.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011250339.png" alt="image-20240325101116834"></p>
<p>思路2：深度优先搜索，当节点的左右子节点都为空，那么该节点就是叶子节点，如果节点同时存在左节点或右节点，那么他的最小深度就是max（l，r）+1，如果只存在左右子节点之一，那么他的最小深度就是存在的之一节点的深度</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int minDepth(TreeNode root) &#123;</span><br><span class="line">        if(root==null)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if(root.left==null&amp;&amp;root.right==null)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        int depth=Integer.MAX_VALUE;</span><br><span class="line">        if(root.left!=null)&#123;</span><br><span class="line">            depth=Math.min(minDepth(root.left),depth);</span><br><span class="line">        &#125;</span><br><span class="line">        if(root.right!=null)&#123;</span><br><span class="line">            depth=Math.min(minDepth(root.right),depth);</span><br><span class="line">        &#125;</span><br><span class="line">        return depth+1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011250576.png" alt="image-20240325103824070"></p>
<h2 id="7-5-翻转二叉树"><a href="#7-5-翻转二叉树" class="headerlink" title="7.5 翻转二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/invert-binary-tree/">7.5 翻转二叉树</a></h2><p>思路：深度优先搜索，递归遍历每一个节点，将他的左右节点交换位置即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode invertTree(TreeNode root) &#123;</span><br><span class="line">        if(root==null)&#123;</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode tem = root.left;</span><br><span class="line">        root.left=root.right;</span><br><span class="line">        root.right=tem;</span><br><span class="line">        invertTree(root.left);</span><br><span class="line">        invertTree(root.right);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011250952.png" alt="image-20240325104328880"></p>
<p>思路2：广度优先搜索，链表记录每一个节点，然后取出反转</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode invertTree(TreeNode root) &#123;</span><br><span class="line">        if(root==null)&#123;</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        TreeNode cur;</span><br><span class="line">        while(queue.size()&gt;0)&#123;</span><br><span class="line">            for(int i =queue.size();i&gt;0;--i)&#123;</span><br><span class="line">                cur = queue.poll();</span><br><span class="line">                TreeNode tem = cur.left;</span><br><span class="line">                cur.left=cur.right;</span><br><span class="line">                cur.right=tem;</span><br><span class="line">                if(cur.left!=null)&#123;</span><br><span class="line">                    queue.offer(cur.left);</span><br><span class="line">                &#125;</span><br><span class="line">                if(cur.right!=null)&#123;</span><br><span class="line">                    queue.offer(cur.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011250588.png" alt="image-20240325105123877"></p>
<h2 id="7-6-对称二叉树"><a href="#7-6-对称二叉树" class="headerlink" title="7.6 对称二叉树"></a>7.6 对称二叉树</h2><h3 id="7-6-1-对称二叉树"><a href="#7-6-1-对称二叉树" class="headerlink" title="7.6.1 对称二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/symmetric-tree/">7.6.1 对称二叉树</a></h3><p>思路：递归，如果两个数互为镜像，那么应该满足两个条件</p>
<ol>
<li>两个树的根节点具有相同的值</li>
<li>一个树的左右子节点分别和另一个树的右左子节点成镜像</li>
</ol>
<p>确定了这个条件后我们就可以利用递归判断该树是否成镜像</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isSymmetric(TreeNode root) &#123;</span><br><span class="line">        return isequals(root.left,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    boolean isequals(TreeNode left, TreeNode right)&#123;</span><br><span class="line">        if(left==null&amp;&amp;right==null)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if(left==null||right==null||left.val!=right.val)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        boolean isleft = isequals(left.left,right.right);</span><br><span class="line">        boolean isright = isequals(right.left,left.right);</span><br><span class="line">        if(isleft&amp;&amp;isright)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011250696.png" alt="image-20240325144955471"></p>
<p>思路2：迭代，每次把位置在镜像相等的两个元素入队，如果两个元素相同那么按顺序把两个节点的四个位置对称的子节点入队，比较是否对称</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isSymmetric(TreeNode root) &#123;</span><br><span class="line">        return isequals(root.left,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    boolean isequals(TreeNode left, TreeNode right)&#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(left);</span><br><span class="line">        queue.offer(right);</span><br><span class="line">        while(queue.size()&gt;0)&#123;</span><br><span class="line">            left=queue.poll();</span><br><span class="line">            right=queue.poll();</span><br><span class="line">            if(left==null&amp;&amp;right==null)&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if(left==null||right==null||left.val!=right.val)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            queue.offer(left.left);</span><br><span class="line">            queue.offer(right.right);</span><br><span class="line">            queue.offer(left.right);</span><br><span class="line">            queue.offer(right.left);</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011250930.png" alt="image-20240325150043104"></p>
<h3 id="7-6-2-相同的树"><a href="#7-6-2-相同的树" class="headerlink" title="7.6.2 相同的树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/same-tree/">7.6.2 相同的树</a></h3><p>思路：用相同的方式遍历两棵树，如果两棵树的全部节点都相同则相同，如果有一个节点不同则不同，以下是递归+深度优先搜索</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isSameTree(TreeNode p, TreeNode q) &#123;</span><br><span class="line">        if(p==null&amp;&amp;q==null)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if(p==null||q==null||p.val!=q.val)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return isSameTree(p.left,q.left)&amp;&amp;isSameTree(q.right,p.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011250917.png" alt="image-20240325153019439"></p>
<h3 id="7-6-3另一个树的子树"><a href="#7-6-3另一个树的子树" class="headerlink" title="7.6.3另一个树的子树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subtree-of-another-tree/">7.6.3另一个树的子树</a></h3><p>思路：深度优先搜索+暴力匹配，用树的每一个节点为根节点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isSubtree(TreeNode root, TreeNode subRoot) &#123;</span><br><span class="line">        return dfs(root,subRoot);</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean dfs(TreeNode root, TreeNode subRoot)&#123;</span><br><span class="line">        if(root==null)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return isSameTree(root,subRoot)||dfs(root.left,subRoot)||dfs(root.right,subRoot);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isSameTree(TreeNode p, TreeNode q) &#123;</span><br><span class="line">        if(p==null&amp;&amp;q==null)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if(p==null||q==null||p.val!=q.val)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return isSameTree(p.left,q.left)&amp;&amp;isSameTree(q.right,p.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-7-二叉树的最大深度"><a href="#7-7-二叉树的最大深度" class="headerlink" title="7.7 二叉树的最大深度"></a>7.7 二叉树的最大深度</h2><h3 id="7-7-1-二叉树的最大深度"><a href="#7-7-1-二叉树的最大深度" class="headerlink" title="7.7.1 二叉树的最大深度"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">7.7.1 二叉树的最大深度</a></h3><p>见7.4.8</p>
<h3 id="7-7-2-N叉树的最大深度"><a href="#7-7-2-N叉树的最大深度" class="headerlink" title="7.7.2 N叉树的最大深度"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/">7.7.2 N叉树的最大深度</a></h3><p>思路：深度优先搜索+递归，跟上面二叉树的最大深度差不多，一个节点的最大深度为所有子节点的最大深度和最大值+1，通过递归方式找到节点的最大深度</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxDepth(Node root) &#123;</span><br><span class="line">        if(root==null)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int depth=0;</span><br><span class="line">        for(Node node: root.children)&#123;</span><br><span class="line">            depth=Math.max(depth,maxDepth(node));</span><br><span class="line">        &#125;</span><br><span class="line">        return depth+1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011250711.png" alt="image-20240325135749475"></p>
<p>思路2：广度优先搜索，用一个数记录当前层数，每次遍历到下一层+1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxDepth(Node root) &#123;</span><br><span class="line">        if(root==null)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int depth=0;</span><br><span class="line">        Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        while(queue.size()&gt;0)&#123;</span><br><span class="line">            ++depth;</span><br><span class="line">            for(int i=queue.size();i&gt;0;--i)&#123;</span><br><span class="line">                root = queue.poll();</span><br><span class="line">                for(Node node: root.children)&#123;</span><br><span class="line">                    queue.offer(node);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011250456.png" alt="image-20240325140336108"></p>
<h2 id="7-8-二叉树的最小深度"><a href="#7-8-二叉树的最小深度" class="headerlink" title="7.8 二叉树的最小深度"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">7.8 二叉树的最小深度</a></h2><p>见7.4.9</p>
<h2 id="7-9完全二叉树的节点个数"><a href="#7-9完全二叉树的节点个数" class="headerlink" title="7.9完全二叉树的节点个数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-complete-tree-nodes/">7.9完全二叉树的节点个数</a></h2><p>思路：广度优先搜索，记录每一层节点的个数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int countNodes(TreeNode root) &#123;</span><br><span class="line">        if(root==null)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt;queue = new LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        int ans =0 ;</span><br><span class="line">        while(queue.size()&gt;0)&#123;</span><br><span class="line">            ans+=queue.size();</span><br><span class="line">            for(int i=queue.size();i&gt;0;--i)&#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                if(node.left!=null)&#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                if(node.right!=null)&#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011250322.png" alt="image-20240325163127473"></p>
<p>思路2：深度优先搜索，找到每个一个节点就+1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int countNodes(TreeNode root) &#123;</span><br><span class="line">        if(root==null)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return countNodes(root.left)+countNodes(root.right)+1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011250613.png" alt="image-20240325164132038"></p>
<p>思路3：可以根据题目给出的完全二叉树的特点进行计算，对于满二叉树，假设他的层数为n，那么他的节点数量等于2的n次方-1，而一个完全二叉树可以存在多个满二叉树，可以借助满二叉树计算完全二叉树的节点个数，而对于完全二叉树，可以一直找到节点的左节点和右节点，判断他们的层数是否相等，如果相等则是二叉树</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int countNodes(TreeNode root) &#123;</span><br><span class="line">        if(root==null)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode left = root.left;</span><br><span class="line">        TreeNode right = root.right;</span><br><span class="line">        int leftCnt = 0;</span><br><span class="line">        int rightCnt = 0;</span><br><span class="line">        while(left!=null)&#123;</span><br><span class="line">            left=left.left;</span><br><span class="line">            ++leftCnt;</span><br><span class="line">        &#125;</span><br><span class="line">        while(right!=null)&#123;</span><br><span class="line">            right=right.right;</span><br><span class="line">            ++rightCnt;</span><br><span class="line">        &#125;</span><br><span class="line">        if(leftCnt==rightCnt)&#123;</span><br><span class="line">            return (2&lt;&lt;leftCnt)-1;</span><br><span class="line">        &#125;</span><br><span class="line">        return countNodes(root.left)+countNodes(root.right)+1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011250186.png" alt="image-20240325214128210"></p>
<h2 id="7-10-平衡二叉树"><a href="#7-10-平衡二叉树" class="headerlink" title="7.10 平衡二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/balanced-binary-tree/">7.10 平衡二叉树</a></h2><p>思路：计算每个节点的深度，当一个节点的左右子节点深度大于1则不平衡</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isBalanced(TreeNode root) &#123;</span><br><span class="line">        return heigh(root)!=-1;</span><br><span class="line">    &#125;</span><br><span class="line">    public int heigh(TreeNode root)&#123;</span><br><span class="line">        if(root==null)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int leftHeight = heigh(root.left);</span><br><span class="line">        int rightHeight =heigh(root.right);</span><br><span class="line">        if(leftHeight==-1||rightHeight==-1||Math.abs(leftHeight-rightHeight)&gt;1)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        return Math.max(leftHeight,rightHeight)+1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011251000.png" alt="image-20240325223058027"></p>
<h2 id="7-11-二叉树的所有路径"><a href="#7-11-二叉树的所有路径" class="headerlink" title="7.11 二叉树的所有路径"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-paths/">7.11 二叉树的所有路径</a></h2><p>思路：深度优先搜索+递归，每次记录从头到当前节点的路径String，然后拼接</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123;</span><br><span class="line">        List&lt;String&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">        dfs(root,&quot;&quot;,ans);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    public void dfs(TreeNode root, String val, List&lt;String&gt; ans)&#123;</span><br><span class="line">        String s = val;</span><br><span class="line">        if(val.length()&gt;0)&#123;</span><br><span class="line">            s+=&quot;-&gt;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        s+=root.val;</span><br><span class="line">        if(root.left!=null)&#123;</span><br><span class="line">            dfs(root.left,s,ans);</span><br><span class="line">        &#125;</span><br><span class="line">        if(root.right!=null)&#123;</span><br><span class="line">            dfs(root.right,s,ans);</span><br><span class="line">        &#125;</span><br><span class="line">        if(root.left==null&amp;&amp;root.right==null)&#123;</span><br><span class="line">            ans.add(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011251465.png" alt="image-20240326094517600"></p>
<p>用StringBuilder优化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;String&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">    public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123;</span><br><span class="line">        dfs(root,&quot;&quot;);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    public void dfs(TreeNode root, String val)&#123;</span><br><span class="line">        if(root.left==null&amp;&amp;root.right==null)&#123;</span><br><span class="line">            ans.add(new StringBuilder(val).append(root.val).toString());</span><br><span class="line">        &#125;</span><br><span class="line">        String s = new StringBuilder(val).append(root.val).append(&quot;-&gt;&quot;).toString();</span><br><span class="line">        if(root.left!=null)&#123;</span><br><span class="line">            dfs(root.left,s);</span><br><span class="line">        &#125;</span><br><span class="line">        if(root.right!=null)&#123;</span><br><span class="line">            dfs(root.right,s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011251920.png" alt="image-20240326094611436"></p>
<h2 id="7-12-左叶子之和"><a href="#7-12-左叶子之和" class="headerlink" title="7.12 左叶子之和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sum-of-left-leaves/">7.12 左叶子之和</a></h2><p>思路：前序遍历，判断当前节点是否左叶子节点，如果是则直接加</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    int ans=0;</span><br><span class="line">    public int sumOfLeftLeaves(TreeNode root) &#123;</span><br><span class="line">        leftAdd(root,false);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    public void leftAdd(TreeNode root,boolean isLeft)&#123;</span><br><span class="line">        if(root==null)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(root.left==null&amp;&amp;root.right==null&amp;&amp;isLeft)&#123;</span><br><span class="line">            ans+=root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        leftAdd(root.left,true);</span><br><span class="line">        leftAdd(root.right,false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011251789.png" alt="image-20240326125643089"></p>
<h2 id="7-13-找树左下角的值"><a href="#7-13-找树左下角的值" class="headerlink" title="7.13 找树左下角的值"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-bottom-left-tree-value/">7.13 找树左下角的值</a></h2><p>思路：广度优先搜索，找到每一层的第一个元素并记录，最后一层的第一个节点即为最左下角</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int findBottomLeftValue(TreeNode root) &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        int ans=root.val;</span><br><span class="line">        while(queue.size()&gt;0)&#123;</span><br><span class="line">            ans=queue.peek().val;</span><br><span class="line">            for(int i=queue.size();i&gt;0;--i)&#123;</span><br><span class="line">                root=queue.poll();</span><br><span class="line">                if(root.left!=null)&#123;</span><br><span class="line">                    queue.offer(root.left);</span><br><span class="line">                &#125;</span><br><span class="line">                if(root.right!=null)&#123;</span><br><span class="line">                    queue.offer(root.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011251689.png" alt="image-20240326130759962"></p>
<p>思路2：深度优先搜索+递归，用一个链表维护每一层最左侧的节点数值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;Integer&gt; level = new ArrayList&lt;&gt;();</span><br><span class="line">    public int findBottomLeftValue(TreeNode root) &#123;</span><br><span class="line">        dfs(root,0);</span><br><span class="line">        return level.get(level.size()-1);</span><br><span class="line">    &#125;</span><br><span class="line">    public void dfs(TreeNode root, int depth)&#123;</span><br><span class="line">        if(root==null)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(level.size()&lt;=depth)&#123;</span><br><span class="line">            level.add(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        ++depth;</span><br><span class="line">        dfs(root.left,depth);</span><br><span class="line">        dfs(root.right,depth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011251511.png" alt="image-20240326132628049"></p>
<p>优化思路2：因为改用记录当前层数代替链表，减去操作链表的时间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    int res=0;</span><br><span class="line">    int depth=0;</span><br><span class="line">    int maxDepth=-1;</span><br><span class="line">    public int findBottomLeftValue(TreeNode root) &#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public void dfs(TreeNode root)&#123;</span><br><span class="line">        if(root==null)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(depth&gt;maxDepth)&#123;</span><br><span class="line">            depth=maxDepth;</span><br><span class="line">            res=root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        ++depth;</span><br><span class="line">        dfs(root.left);</span><br><span class="line">        dfs(root.right);</span><br><span class="line">        --depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011251225.png" alt="image-20240326140344010"></p>
<h2 id="7-14-路径总和"><a href="#7-14-路径总和" class="headerlink" title="7.14 路径总和"></a>7.14 路径总和</h2><h3 id="7-14-1-路径总和"><a href="#7-14-1-路径总和" class="headerlink" title="7.14.1 路径总和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum/">7.14.1 路径总和</a></h3><p>思路：深度优先搜索，用一个值记录从根节点到当前节点的值的总和，如果当前节点为根节点且总和登录给定的目标总和，那么返回true，否则返回false</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    int sum=0;</span><br><span class="line">    public boolean hasPathSum(TreeNode root, int targetSum) &#123;</span><br><span class="line">        if(root==null)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        sum+=root.val;</span><br><span class="line">        if(root.left==null&amp;&amp;root.right==null&amp;&amp;sum==targetSum)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        boolean leftSum = hasPathSum(root.left,targetSum);</span><br><span class="line">        boolean rightSum = hasPathSum(root.right,targetSum);</span><br><span class="line">        sum-=root.val;</span><br><span class="line">        return leftSum||rightSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011251064.png" alt="image-20240326141447586"></p>
<h3 id="7-14-2-路径总和Ⅱ"><a href="#7-14-2-路径总和Ⅱ" class="headerlink" title="7.14.2 路径总和Ⅱ"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum-ii/">7.14.2 路径总和Ⅱ</a></h3><p>思路：深度优先搜索，用栈记录一条路线上的节点值，当遍历到叶子节点且节点之和等于目标值，就用栈中的队列创建一条链表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; path = new Stack&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int targetSum) &#123;</span><br><span class="line">        dfs(root,targetSum);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    public void dfs(TreeNode root, int targetSum)&#123;</span><br><span class="line">        if(root==null)&#123;</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line">        targetSum-=root.val;</span><br><span class="line">        path.push(root.val);</span><br><span class="line">        if(root.left==null&amp;&amp;root.right==null&amp;&amp;targetSum==0)&#123;</span><br><span class="line">            ans.add(new ArrayList&lt;&gt;(path));</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.left,targetSum);</span><br><span class="line">        dfs(root.right,targetSum);</span><br><span class="line">        targetSum+=root.val;</span><br><span class="line">        path.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011251939.png" alt="image-20240327091008948"></p>
<h2 id="7-15-从中序与后续遍历序列构造二叉树"><a href="#7-15-从中序与后续遍历序列构造二叉树" class="headerlink" title="7.15 从中序与后续遍历序列构造二叉树"></a>7.15 从中序与后续遍历序列构造二叉树</h2><h3 id="7-15-1-从中序与后续遍历序列构造二叉树"><a href="#7-15-1-从中序与后续遍历序列构造二叉树" class="headerlink" title="7.15.1 从中序与后续遍历序列构造二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">7.15.1 从中序与后续遍历序列构造二叉树</a></h3><p>思路：后序遍历的最后一个节点为根节点，题目给出的关键条件是inorder和postorder都由不同的值组成，所以我们可以根据后续遍历的最后一个节点把中序遍历分为左右子树的两部分，重复操作接口构造原二叉树</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode buildTree(int[] inorder, int[] postorder) &#123;</span><br><span class="line">        return divide(inorder,0,inorder.length-1,postorder,0,postorder.length-1);</span><br><span class="line">    &#125;</span><br><span class="line">    public TreeNode divide(int[] inorder,int inbegin,int inend,int[] postorder, int pobegin,int poend)&#123;</span><br><span class="line">        if(inbegin==inend)&#123;</span><br><span class="line">            return new TreeNode(inorder[inbegin]);</span><br><span class="line">        &#125;</span><br><span class="line">        if(inbegin&gt;inend)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        int index=0;</span><br><span class="line">        for(int i=inbegin;i&lt;=inend;++i)&#123;</span><br><span class="line">            if(inorder[i]==postorder[poend])&#123;</span><br><span class="line">                index=i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode node = new TreeNode(inorder[index]);</span><br><span class="line">        node.left = divide(inorder,inbegin,index-1,postorder,pobegin,pobegin+(index-1-inbegin));</span><br><span class="line">        node.right = divide(inorder,index+1,inend,postorder,pobegin+(index-inbegin),poend-1);</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011251376.png" alt="image-20240327110738125"></p>
<p>优化：用map记录数值和索引中间的映射关系，优化每次遍历数组查找</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">    public TreeNode buildTree(int[] inorder, int[] postorder) &#123;</span><br><span class="line">        for(int i=0;i&lt;inorder.length;++i)&#123;</span><br><span class="line">            map.put(inorder[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        return divide(inorder,0,inorder.length-1,postorder,0,postorder.length-1);</span><br><span class="line">    &#125;</span><br><span class="line">    public TreeNode divide(int[] inorder,int inbegin,int inend,int[] postorder, int pobegin,int poend)&#123;</span><br><span class="line">        if(inbegin==inend)&#123;</span><br><span class="line">            return new TreeNode(inorder[inbegin]);</span><br><span class="line">        &#125;</span><br><span class="line">        if(inbegin&gt;inend)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        int index=map.get(postorder[poend]);</span><br><span class="line">        TreeNode node = new TreeNode(inorder[index]);</span><br><span class="line">        node.left = divide(inorder,inbegin,index-1,postorder,pobegin,pobegin+(index-1-inbegin));</span><br><span class="line">        node.right = divide(inorder,index+1,inend,postorder,pobegin+(index-inbegin),poend-1);</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011251284.png" alt="image-20240327111515337"></p>
<h3 id="7-15-2-从前序与中序遍历序列构造二叉树"><a href="#7-15-2-从前序与中序遍历序列构造二叉树" class="headerlink" title="7.15.2 从前序与中序遍历序列构造二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">7.15.2 从前序与中序遍历序列构造二叉树</a></h3><p>思路：跟上题思路基本一致，上题根据后续遍历最后一个节点不断分区域，而前序遍历可以根据第一个节点分区域</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">    public TreeNode buildTree(int[] preorder, int[] inorder) &#123;</span><br><span class="line">        for(int i=0;i&lt;inorder.length;++i)&#123;</span><br><span class="line">            map.put(inorder[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        return divide(preorder,0,preorder.length-1,inorder,0,inorder.length-1);</span><br><span class="line">    &#125;</span><br><span class="line">    public TreeNode divide(int[] preorder,int prebegin,int preend,int[] inorder, int inbegin,int inend)&#123;</span><br><span class="line">        if(inbegin==inend)&#123;</span><br><span class="line">            return new TreeNode(inorder[inbegin]);</span><br><span class="line">        &#125;</span><br><span class="line">        if(inbegin&gt;inend||prebegin&gt;=inorder.length)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        int index=map.get(preorder[prebegin]);</span><br><span class="line">        TreeNode node = new TreeNode(inorder[index]);</span><br><span class="line">        node.left = divide(preorder,prebegin+1,prebegin+(index-inbegin),inorder,inbegin,index-1);</span><br><span class="line">        node.right = divide(preorder,prebegin+(index-inbegin)+1,preend,inorder,index+1,inend);</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011251166.png" alt="image-20240327150949720"></p>
<h2 id="7-16-最大二叉树"><a href="#7-16-最大二叉树" class="headerlink" title="7.16 最大二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-binary-tree/">7.16 最大二叉树</a></h2><p>思路：找到数组中的最大值，将数组分为两部分，再找到最大值继续构建二叉树</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode constructMaximumBinaryTree(int[] nums) &#123;</span><br><span class="line">        return makeTree(nums,0,nums.length-1);</span><br><span class="line">    &#125;</span><br><span class="line">    public TreeNode makeTree(int[]nums,int begin, int end)&#123;</span><br><span class="line">        if(begin&gt;end)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        if(begin==end)&#123;</span><br><span class="line">            return new TreeNode(nums[begin]);</span><br><span class="line">        &#125;</span><br><span class="line">        int index=begin;</span><br><span class="line">        for(int i=begin+1;i&lt;=end;++i)&#123;</span><br><span class="line">            if(nums[i]&gt;nums[index])&#123;</span><br><span class="line">                index=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root = new TreeNode(nums[index]);</span><br><span class="line">        root.left = makeTree(nums,begin,index-1);</span><br><span class="line">        root.right = makeTree(nums,index+1,end);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011251216.png" alt="image-20240327152247466"></p>
<h2 id="7-17-合并二叉树"><a href="#7-17-合并二叉树" class="headerlink" title="7.17 合并二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-binary-tree/">7.17 合并二叉树</a></h2><p>思路：简单的模拟，注意空指针问题即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) &#123;</span><br><span class="line">        if(root1==null&amp;&amp;root2==null)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        int value=0;</span><br><span class="line">        TreeNode left1=null;</span><br><span class="line">        TreeNode right1=null;</span><br><span class="line">        TreeNode left2=null;</span><br><span class="line">        TreeNode right2=null;</span><br><span class="line">        if(root1!=null)&#123;</span><br><span class="line">            value+=root1.val;</span><br><span class="line">            left1=root1.left;</span><br><span class="line">            right1=root1.right;</span><br><span class="line">        &#125;</span><br><span class="line">        if(root2!=null)&#123;</span><br><span class="line">            value+=root2.val;</span><br><span class="line">            left2=root2.left;</span><br><span class="line">            right2=root2.right;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode node = new TreeNode(value);</span><br><span class="line">        node.left=mergeTrees(left1,left2);</span><br><span class="line">        node.right=mergeTrees(right1,right2);</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011251559.png" alt="image-20240327153253036"></p>
<h2 id="7-18-二叉搜索树的搜索"><a href="#7-18-二叉搜索树的搜索" class="headerlink" title="7.18 二叉搜索树的搜索"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">7.18 二叉搜索树的搜索</a></h2><p>思路：根据二叉搜索树的特点，如果节点的值比目标值大，则去他的左子树找，如果节点的值比目标值小，则去他的右子树找，如果相等，则该节点即为所求</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode searchBST(TreeNode root, int val) &#123;</span><br><span class="line">        if(root==null)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;else if(root.val==val)&#123;</span><br><span class="line">            return root;</span><br><span class="line">        &#125;else if(root.val&gt;val)&#123;</span><br><span class="line">            return searchBST(root.left,val);</span><br><span class="line">        &#125;</span><br><span class="line">        return searchBST(root.right,val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011251096.png" alt="image-20240327153659553"></p>
<h2 id="7-19-验证二叉搜索树"><a href="#7-19-验证二叉搜索树" class="headerlink" title="7.19 验证二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/validate-binary-search-tree/">7.19 验证二叉搜索树</a></h2><p>思路：二叉搜索树每个节点的右子树节点都比自身节点的数值大，左子树节点都比自身的数值小，利用这个特性，记录节点数值的范围，递归判断</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isValidBST(TreeNode root) &#123;</span><br><span class="line">        return isValidBST(root,Long.MIN_VALUE,Long.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean isValidBST(TreeNode root, long min,long max)&#123;</span><br><span class="line">        if(root==null)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if(min&gt;=root.val||max&lt;=root.val)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return isValidBST(root.left,min,root.val)&amp;&amp;isValidBST(root.right,root.val,max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011251929.png" alt="image-20240327160052501"></p>
<h2 id="7-20-二叉搜索树的最小绝对差"><a href="#7-20-二叉搜索树的最小绝对差" class="headerlink" title="7.20 二叉搜索树的最小绝对差"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/">7.20 二叉搜索树的最小绝对差</a></h2><p>思路：中序遍历，记录上一个节点的值，中序遍历二叉搜索树可以保证上一个节点的值比当前节点值要小，每次计算出差值并且比较找到最小差值即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    int min = Integer.MAX_VALUE;</span><br><span class="line">    int pre=-1;</span><br><span class="line">    public int getMinimumDifference(TreeNode root) &#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        return min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void dfs(TreeNode root) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.left);</span><br><span class="line">        if(pre==-1)&#123;</span><br><span class="line">            pre=root.val;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            min=Math.min(min,root.val-pre);</span><br><span class="line">            pre=root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011251881.png" alt="image-20240327163549510"></p>
<h2 id="7-21-二叉搜索树中的众数"><a href="#7-21-二叉搜索树中的众数" class="headerlink" title="7.21 二叉搜索树中的众数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/">7.21 二叉搜索树中的众数</a></h2><p>思路：利用二叉搜索树左子树节点比当前节点小，右子树节点比当前节点大的特点，中序遍历二叉搜索树可以保证遍历到的数值从小到大，用链表记录当前出现次数最多的节点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    int pre=-1;</span><br><span class="line">    int cnt=0;</span><br><span class="line">    int max=0;</span><br><span class="line">    List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">    public int[] findMode(TreeNode root) &#123;</span><br><span class="line">        inorderTraversal(root);</span><br><span class="line">        int[] ansArray = new int[ans.size()];</span><br><span class="line">        for(int i=0;i&lt;ans.size();++i)&#123;</span><br><span class="line">            ansArray[i]=ans.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return ansArray;</span><br><span class="line">    &#125;</span><br><span class="line">    public void inorderTraversal(TreeNode root)&#123;</span><br><span class="line">        if(root==null)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        inorderTraversal(root.left);</span><br><span class="line">        if(root.val==pre)&#123;</span><br><span class="line">            ++cnt;</span><br><span class="line">            if(cnt==max)&#123;</span><br><span class="line">                ans.add(root.val);</span><br><span class="line">            &#125;else if (cnt&gt;max)&#123;</span><br><span class="line">                ans.clear();</span><br><span class="line">                max=cnt;</span><br><span class="line">                ans.add(root.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            pre=root.val;</span><br><span class="line">            cnt=1;</span><br><span class="line">            if(cnt==max)&#123;</span><br><span class="line">                ans.add(root.val);</span><br><span class="line">            &#125;else if(cnt&gt;max)&#123;</span><br><span class="line">                ans.add(root.val);</span><br><span class="line">                max=1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        inorderTraversal(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011251448.png" alt="image-20240328095358917"></p>
<h2 id="7-22-二叉树的最近公共祖先"><a href="#7-22-二叉树的最近公共祖先" class="headerlink" title="7.22 二叉树的最近公共祖先"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">7.22 二叉树的最近公共祖先</a></h2><p>思路：深度优先搜索+递归，可以根据返回值判断当前节点是否目标节点的祖先节点，如果是目标节点的祖先节点则返回目标节点，否则返回null，当有一个节点的左右子节点返回都不是null，则代表这个节点是两节点公共祖先</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class="line">        if(root==null)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        if(root==p||root==q)&#123;</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right,p,q);</span><br><span class="line">        if(left!=null&amp;&amp;right!=null)&#123;</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line">        if(left!=null)&#123;</span><br><span class="line">            return left;</span><br><span class="line">        &#125;</span><br><span class="line">        return right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/sunsetsouol/pic/raw/pic/picture/202403281036309.png" alt="image-20240328101848075"></p>
<h2 id="7-23-二叉搜索树的最近公共祖先"><a href="#7-23-二叉搜索树的最近公共祖先" class="headerlink" title="7.23 二叉搜索树的最近公共祖先"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">7.23 二叉搜索树的最近公共祖先</a></h2><p>思路：根据二叉搜索树的特点，两个节点的最近公共祖先的值一定位于这两个节点的值中间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class="line">        TreeNode ancestor = root;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            if(p.val&lt;ancestor.val&amp;&amp;q.val&lt;ancestor.val)&#123;</span><br><span class="line">                ancestor=ancestor.left;</span><br><span class="line">            &#125;else if (p.val&gt;ancestor.val&amp;&amp;q.val&gt;ancestor.val)&#123;</span><br><span class="line">                ancestor=ancestor.right;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ancestor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011252805.png" alt="image-20240328112039024"></p>
<h2 id="7-24-二叉搜索树中的插入操作"><a href="#7-24-二叉搜索树中的插入操作" class="headerlink" title="7.24 二叉搜索树中的插入操作"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/">7.24 二叉搜索树中的插入操作</a></h2><p>思路：根据二叉搜索树的特点，如果目标值比当前节点大就往右子树遍历，如果比当前节点小就往左子树遍历，直到节点为空就创建一个目标值的节点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode insertIntoBST(TreeNode root, int val) &#123;</span><br><span class="line">        if(root==null)&#123;</span><br><span class="line">            return new TreeNode(val);</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode ancestor = root;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            if(ancestor.val&gt;val)&#123;</span><br><span class="line">                if(ancestor.left!=null)&#123;</span><br><span class="line">                    ancestor=ancestor.left;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    ancestor.left=new TreeNode(val);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else if(ancestor.val&lt;val)&#123;</span><br><span class="line">                if(ancestor.right!=null)&#123;</span><br><span class="line">                    ancestor=ancestor.right;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    ancestor.right=new TreeNode(val);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011252221.png" alt="image-20240328113449785"></p>
<h2 id="7-25-删除二叉搜索树中的节点"><a href="#7-25-删除二叉搜索树中的节点" class="headerlink" title="7.25 删除二叉搜索树中的节点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/delete-node-in-a-bst/">7.25 删除二叉搜索树中的节点</a></h2><p>思路：首先利用二叉搜索树的特性找到目标节点并记录目标节点的父节点，其次就是删除节点后对删除节点的子树的处理，特别多坑，有很多地方都需要注意</p>
<p>首先判断要删除节点的状态，如果左右子树都为空，那么直接删除节点即可</p>
<p>如果要删除节点的只存在左子树或右子树中的一个，那么将左右子树中存在的一个放到原来要删除节点的位置即可</p>
<p>如果要删除节点的左右子树都存在，那么为了维持二叉搜索树的特点，需要在保证子树不变的前提下，找到一个合适的节点代替被删除节点的位置，可以找到右子树最小的节点或左子树最大的节点保证二叉搜索树的性质不变，这里采用找到右子树的最小节点代替实现</p>
<p>首先我们要找到右子树的最小节点，就要从被删除节点的右子节点开始，因为比被删除节点大的元素节点都在他的右子树上，而要找到这个子树的最小节点，就要从子树的根节点开始一直往左子节点遍历直到左子节点为空，得到的节点即为所需的比被删除节点大的最小节点</p>
<p>然后就是将这个节点替换到被删除节点的位置，首先需要处理这个节点的子树，因为这个节点的左子树为空，所以直接将他的右子树迁移到该节点原本的位置即可，就是将这个节点顶替到被删除节点的位置，然后将这个节点的左右子节点绑定被删除节点的左右子节点</p>
<p>这个时候又需要分几种情况，首先是被删除节点的父节点为空，那么代表被删除节点是根节点，这时候直接返回顶替好的节点即可</p>
<p>当被删除节点的根节点存在，需要判断被删除节点是他的左节点还是右节点，然后绑定返回原根节点即可，这里只需注意空指针即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode deleteNode(TreeNode root, int key) &#123;</span><br><span class="line">        TreeNode cur = root;</span><br><span class="line">        TreeNode ancestor = null;</span><br><span class="line">        while(cur!=null&amp;&amp;cur.val!=key)&#123;</span><br><span class="line">            if(cur.val&lt;key)&#123;</span><br><span class="line">                ancestor=cur;</span><br><span class="line">                cur=cur.right;</span><br><span class="line">            &#125;else if (cur.val&gt;key)&#123;</span><br><span class="line">                ancestor=cur;</span><br><span class="line">                cur=cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(cur==null)&#123;</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line">        if(cur.left==null&amp;&amp;cur.right==null)&#123;</span><br><span class="line">            cur=null;</span><br><span class="line">        &#125;else if(cur.left==null)&#123;</span><br><span class="line">            cur=cur.right;</span><br><span class="line">        &#125;else if(cur.right==null)&#123;</span><br><span class="line">            cur=cur.left;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            TreeNode minParent=cur;</span><br><span class="line">            TreeNode min=cur.right;</span><br><span class="line">            while(min.left!=null)&#123;</span><br><span class="line">                minParent=min;</span><br><span class="line">                min=min.left;</span><br><span class="line">            &#125;</span><br><span class="line">            if(minParent==cur)&#123;</span><br><span class="line">                minParent.right=min.right;    </span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                minParent.left=min.right;</span><br><span class="line">            &#125;</span><br><span class="line">            min.left=cur.left;</span><br><span class="line">            min.right=cur.right;</span><br><span class="line">            cur=min;</span><br><span class="line">        &#125;</span><br><span class="line">        if(ancestor==null)&#123;</span><br><span class="line">            return cur;</span><br><span class="line">        &#125;</span><br><span class="line">        if(ancestor.left!=null&amp;&amp;ancestor.left.val==key)&#123;</span><br><span class="line">            ancestor.left=cur;</span><br><span class="line">        &#125;else if(ancestor.right!=null&amp;&amp;ancestor.right.val==key)&#123;</span><br><span class="line">            ancestor.right=cur;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011252076.png" alt="image-20240328202736198"></p>
<h2 id="7-26-修剪二叉搜索树"><a href="#7-26-修剪二叉搜索树" class="headerlink" title="7.26 修剪二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/trim-a-binary-search-tree/">7.26 修剪二叉搜索树</a></h2><p>思路：刚刚拿到这道题感觉很难，思维停留在上一题要删除节点后保持二叉搜索树的性质，删除一个小于low的节点后，节点的右子树可能有部分节点满足在low和high之间，要将这些节点找到并且重构一个二叉树比较复杂。</p>
<p>但是重新想一下二叉搜索树的特点，左子树的节点都比当前节点小，右子树的节点都比当前节点大，所以某一个节点不满足[low,high]条件时，左右子树至少有一方不满足条件，假设某个节点比low小，左子树的节点全都比当前节点小，那么必然比low小，所以左子树肯定不符合条件，这时只需要考虑右子树；假设节点比high大，右子树节点全部比当前节点大，那么必然比high大，所以右子树肯定不符合条件</p>
<p>所以如果要删除某个节点，最多只需要保留他的一个子树，只需要让该子节点顶替需要删除的节点位置即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode trimBST(TreeNode root, int low, int high) &#123;</span><br><span class="line">        if(root==null)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        if(root.val&gt;=low&amp;&amp;root.val&lt;=high)&#123;</span><br><span class="line">            root.left=trimBST(root.left,low,high);</span><br><span class="line">            root.right=trimBST(root.right,low,high);</span><br><span class="line">            return root;</span><br><span class="line">        &#125;else if(root.val&lt;low)&#123;</span><br><span class="line">            return trimBST(root.right,low,high);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return trimBST(root.left,low,high);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011252978.png" alt="image-20240406170753450"></p>
<h2 id="7-27-将有序数组转换为二叉搜索树"><a href="#7-27-将有序数组转换为二叉搜索树" class="headerlink" title="7.27 将有序数组转换为二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">7.27 将有序数组转换为二叉搜索树</a></h2><p>思路：递归，要求一个平衡二叉搜索树，最简单的就是将数组中间的元素作为根节点，然后将数组分为左右两部分，左边作为左子树，右边作为右子树，不断分割递归</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode sortedArrayToBST(int[] nums) &#123;</span><br><span class="line">        return sortedArrayToBST(nums,0,nums.length-1);</span><br><span class="line">    &#125;</span><br><span class="line">    public TreeNode sortedArrayToBST(int[]nums, int begin, int end)&#123;</span><br><span class="line">        if(begin&gt;end)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        if(begin==end)&#123;</span><br><span class="line">            return new TreeNode(nums[begin]);</span><br><span class="line">        &#125;</span><br><span class="line">        int mid=(begin+end)/2;</span><br><span class="line">        TreeNode root = new TreeNode(nums[mid]);</span><br><span class="line">        root.left=sortedArrayToBST(nums,begin,mid-1);</span><br><span class="line">        root.right=sortedArrayToBST(nums,mid+1,end);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011252380.png" alt="image-20240406193705101"></p>
<h2 id="7-28把二叉搜索树转换成累加数"><a href="#7-28把二叉搜索树转换成累加数" class="headerlink" title="7.28把二叉搜索树转换成累加数"></a>7.28把二叉搜索树转换成累加数</h2><p>思路：首先二叉搜索树是有序的，要将二叉搜索树的节点变成比自己大的节点的累加，只需要按照右子树，父节点，左子树的顺序，将路程遇到的节点累加即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    int sum=0;</span><br><span class="line">    public TreeNode convertBST(TreeNode root) &#123;</span><br><span class="line">        travel(root);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    public void travel(TreeNode root)&#123;</span><br><span class="line">        if(root==null)&#123;</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line">        travel(root.right);</span><br><span class="line">        sum+=root.val;</span><br><span class="line">        root.val=sum;</span><br><span class="line">        travel(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011252697.png" alt="image-20240422145927426"></p>
<h1 id="8-回溯算法"><a href="#8-回溯算法" class="headerlink" title="8.回溯算法"></a>8.回溯算法</h1><h2 id="8-1-组合问题"><a href="#8-1-组合问题" class="headerlink" title="8.1 组合问题"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combinations/">8.1 组合问题</a></h2><p>思路：如果是确定了组合k的次数，那么只需要k层循环，每次循环选择一个数作到当前位置，一个数确定后的所有情况确定后换下一个数找到所有情况即可，但是这里k的个数是不确定的，这时候我们可以使用递归进行回溯，用一个全局变量path记录当前路径遍历到的元素，根据path的大小确定当前遍历的位置，每次回溯后去除path的最后一个节点重新维护下一个元素</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path = new ArrayList&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123;</span><br><span class="line">        backTracking(n,k,1);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    public void backTracking(int n,int k,int index)&#123;</span><br><span class="line">        if(path.size()==k)&#123;</span><br><span class="line">            ans.add(new ArrayList&lt;&gt;(path));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=index;i&lt;=n;++i)&#123;</span><br><span class="line">            path.add(i);</span><br><span class="line">            backTracking(n,k,i+1);</span><br><span class="line">            path.remove(path.size()-1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011253621.png" alt="image-20240406220057531"></p>
<p>优化：剪枝，对于回溯后剩下元素和path中元素加起来总和小于k时，已经不可能再凑成k个元素的组合了，这时候就可以直接退出了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path = new ArrayList&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123;</span><br><span class="line">        backTracking(n,k,1);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    public void backTracking(int n,int k,int index)&#123;</span><br><span class="line">        if(path.size()==k)&#123;</span><br><span class="line">            ans.add(new ArrayList&lt;&gt;(path));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=index;i&lt;=n-(k-path.size())+1;++i)&#123;</span><br><span class="line">            path.add(i);</span><br><span class="line">            backTracking(n,k,i+1);</span><br><span class="line">            path.remove(path.size()-1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011253168.png"></p>
<h2 id="8-2-组合总和Ⅲ"><a href="#8-2-组合总和Ⅲ" class="headerlink" title="8.2 组合总和Ⅲ"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-iii/">8.2 组合总和Ⅲ</a></h2><p>思路：还是回溯，跟上题类似，但是不同的是，这里不止是纯粹的组合回溯，只有当路径总结相加等于目标值的时候才要将路径组合值添加到答案中</p>
<p>首先确定这里需要两个全局变量记录当前的路径和符合条件的路径的集合，其次还需要在递归的时候传递一个起始索引保证不会重复</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path = new ArrayList&lt;&gt;();</span><br><span class="line">    int pathSum=0;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) &#123;</span><br><span class="line">        backTracking(k,n,1);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    public void backTracking(int k, int n, int index)&#123;</span><br><span class="line">        if(path.size()==k)&#123;</span><br><span class="line">            if(pathSum==n)&#123;</span><br><span class="line">                ans.add(new ArrayList&lt;&gt;(path));</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=index;i&lt;=9;++i)&#123;</span><br><span class="line">            path.add(i);</span><br><span class="line">            pathSum+=i;</span><br><span class="line">            backTracking(k,n,i+1);</span><br><span class="line">            path.remove(path.size()-1);</span><br><span class="line">            pathSum-=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011253125.png" alt="image-20240406222953395"></p>
<p>优化：剪枝，当当前元素和超过目标和的时候就没有必要继续往下遍历了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path = new ArrayList&lt;&gt;();</span><br><span class="line">    int pathSum=0;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) &#123;</span><br><span class="line">        backTracking(k,n,1);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    public void backTracking(int k, int n, int index)&#123;</span><br><span class="line">        if(pathSum&gt;n)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(path.size()==k)&#123;</span><br><span class="line">            if(pathSum==n)&#123;</span><br><span class="line">                ans.add(new ArrayList&lt;&gt;(path));</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=index;i&lt;=9;++i)&#123;</span><br><span class="line">            path.add(i);</span><br><span class="line">            pathSum+=i;</span><br><span class="line">            backTracking(k,n,i+1);</span><br><span class="line">            path.remove(path.size()-1);</span><br><span class="line">            pathSum-=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011253644.png" alt="image-20240406223452654"></p>
<h2 id="8-3-电话号码的字母组合"><a href="#8-3-电话号码的字母组合" class="headerlink" title="8.3 电话号码的字母组合"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">8.3 电话号码的字母组合</a></h2><p>思路：先创建一张数字到对应字母的映射表，然后还是像上面的题一样，遍历电话号码的每一位，将每一个电话号码映射的字母都遍历回溯一遍，就可以得到全部的组合，但是这里是多集合取组合，每个数字对应一个集合，集合之间互不影响，所以不需要起始索引</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;String&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">    Map&lt;Character,Character[]&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">    &#123;</span><br><span class="line">        map.put(&#x27;2&#x27;,new Character[]&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;);</span><br><span class="line">        map.put(&#x27;3&#x27;,new Character[]&#123;&#x27;d&#x27;,&#x27;e&#x27;,&#x27;f&#x27;&#125;);</span><br><span class="line">        map.put(&#x27;4&#x27;,new Character[]&#123;&#x27;g&#x27;,&#x27;h&#x27;,&#x27;i&#x27;&#125;);</span><br><span class="line">        map.put(&#x27;5&#x27;,new Character[]&#123;&#x27;j&#x27;,&#x27;k&#x27;,&#x27;l&#x27;&#125;);</span><br><span class="line">        map.put(&#x27;6&#x27;,new Character[]&#123;&#x27;m&#x27;,&#x27;n&#x27;,&#x27;o&#x27;&#125;);</span><br><span class="line">        map.put(&#x27;7&#x27;,new Character[]&#123;&#x27;p&#x27;,&#x27;q&#x27;,&#x27;r&#x27;,&#x27;s&#x27;&#125;);</span><br><span class="line">        map.put(&#x27;8&#x27;,new Character[]&#123;&#x27;t&#x27;,&#x27;u&#x27;,&#x27;v&#x27;&#125;);</span><br><span class="line">        map.put(&#x27;9&#x27;,new Character[]&#123;&#x27;w&#x27;,&#x27;x&#x27;,&#x27;y&#x27;,&#x27;z&#x27;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    public List&lt;String&gt; letterCombinations(String digits) &#123;</span><br><span class="line">        if(digits.length()==0)&#123;dj</span><br><span class="line">            return ans;</span><br><span class="line">        &#125;</span><br><span class="line">        char[]path = new char[digits.length()];</span><br><span class="line">        backTracking(digits,0,path);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    public void backTracking(String digits,int index,char[]path)&#123;</span><br><span class="line">        if(index==digits.length())&#123;</span><br><span class="line">            ans.add(new String(path));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(Character ch:map.get(digits.charAt(index)))&#123;</span><br><span class="line">            path[index]=ch;</span><br><span class="line">            backTracking(digits,index+1,path);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011253224.png" alt="image-20240406230439829"></p>
<h2 id="8-4-组合总和"><a href="#8-4-组合总和" class="headerlink" title="8.4 组合总和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum/">8.4 组合总和</a></h2><p>思路：回溯，这题跟上面8.2组合总和Ⅲ差不多，唯一的区别就是这里数组中的元素是无限制的，所以在递归遍历的时候不需要关注层数，只需要关注路径总和是否大于target</p>
<p>首先我们确定需要的全局变量，这里需要的全局变量跟上面8.2组合总和Ⅲ差不多，都是一个记录符合条件路径list的list，还有就是记录当前递归路径的list和当前总和，最后还需要在递归的时候传递一个起始索引保证不重复</p>
<p>因为这里不限元素个数，索引递归的终止条件只需要考虑路径总和大于目标值</p>
<p>对于每次循环的，只需要从起始索引开始搜索数组，但是因为元素是可以被重复选取的，所以在递归调用的时候，下一次调用的起始索引就不是i+1了，而是i</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path = new ArrayList&lt;&gt;();</span><br><span class="line">    int pathSum=0;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123;</span><br><span class="line">        backTracking(candidates,target,0);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    public void backTracking(int[] candidates,int target,int index)&#123;</span><br><span class="line">        if(pathSum&gt;target)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(pathSum==target)&#123;</span><br><span class="line">            ans.add(new ArrayList&lt;&gt;(path));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=index;i&lt;candidates.length;++i)&#123;</span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            pathSum+=candidates[i];</span><br><span class="line">            backTracking(candidates,target,i);</span><br><span class="line">            path.remove(path.size()-1);</span><br><span class="line">            pathSum-=candidates[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011253371.png" alt="image-20240407095950505"></p>
<h2 id="8-5-组合总和Ⅱ"><a href="#8-5-组合总和Ⅱ" class="headerlink" title="8.5 组合总和Ⅱ"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-ii/">8.5 组合总和Ⅱ</a></h2><p>思路：还是回溯，这题跟上一题 8.4组合总和的区别就是，上一题的元素可以重复无限使用，这里每个元素只能使用一次，并且元素可以重复且解集不能包含重复的组合，为了保证相同的元素被使用两次，就要保证每个位置只会出现一个相同的元素，可以将原数组排序后然后比较当前索引元素跟上一个位置的元素是否相同判断是否重复</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path = new ArrayList&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        backTracking(candidates,target,0);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    public void backTracking(int[] candidates,int target, int index)&#123;</span><br><span class="line">        if(target==0)&#123;</span><br><span class="line">            ans.add(new ArrayList&lt;&gt;(path));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=index;i&lt;candidates.length;++i)&#123;</span><br><span class="line">            if(i&gt;index&amp;&amp;candidates[i]==candidates[i-1])&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            backTracking(candidates,target-candidates[i],i+1);</span><br><span class="line">            path.remove(path.size()-1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011253732.png" alt="image-20240407154329030"></p>
<p>但是没想到最后超时了，这里继续思考一下这个算法有什么可以优化的地方</p>
<p>数组已经排序过了，所以数组后边的元素一定比前边的元素大，如果数组添加到当前位置总和就大于目标值，那么继续往后遍历就更大与目标值了，这时候就没有必要继续遍历下去了，通过这个简单的剪枝操作，就可以通过了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path = new ArrayList&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        backTracking(candidates,target,0);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    public void backTracking(int[] candidates,int target, int index)&#123;</span><br><span class="line">        if(target==0)&#123;</span><br><span class="line">            ans.add(new ArrayList&lt;&gt;(path));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=index;i&lt;candidates.length;++i)&#123;</span><br><span class="line">            if(i&gt;index&amp;&amp;candidates[i]==candidates[i-1])&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if(candidates[i]&gt;target)&#123;	//剪枝</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            backTracking(candidates,target-candidates[i],i+1);</span><br><span class="line">            path.remove(path.size()-1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011253435.png" alt="image-20240407154738649"></p>
<h2 id="8-6-分割回文串"><a href="#8-6-分割回文串" class="headerlink" title="8.6 分割回文串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindrome-partitioning/">8.6 分割回文串</a></h2><p>思路：这里需要找到s分割的全部方案还是需要通过回溯进行枚举，回文字符串的判断可以通过双指针法判断，也可以通过动态规划进行判断</p>
<p>这里要将s分割成每个子串都是回文串，找到上一个回文子串后，需要枚举出以当前索引开始的全部回文串，很适合使用动态规划去做</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; path = new ArrayList&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</span><br><span class="line">        int[][]dp=new int[s.length()][s.length()];</span><br><span class="line">        for(int i=s.length()-1;i&gt;=0;--i)&#123;</span><br><span class="line">            for(int j=i;j&lt;s.length();++j)&#123;</span><br><span class="line">                if(s.charAt(i)==s.charAt(j))&#123;</span><br><span class="line">                    if(j-i&lt;=1 || dp[i+1][j-1]==1)&#123;</span><br><span class="line">                        dp[i][j]=1;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        backTracking(s,0,dp);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    public void backTracking(String s,int index, int[][]dp)&#123;</span><br><span class="line">        if(index&gt;=s.length() )&#123;</span><br><span class="line">            ans.add(new ArrayList&lt;&gt;(path));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=index;i&lt;s.length();++i)&#123;</span><br><span class="line">            if(dp[index][i]==1)&#123;</span><br><span class="line">                path.add(s.substring(index,i+1));</span><br><span class="line">                backTracking(s,i+1,dp);</span><br><span class="line">                path.remove(path.size()-1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011253739.png" alt="image-20240408151258224"></p>
<h2 id="8-7-复原IP地址"><a href="#8-7-复原IP地址" class="headerlink" title="8.7 复原IP地址"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/restore-ip-addresses/">8.7 复原IP地址</a></h2><p>思路：首先还是要用回溯找到全部的情况，首先确定递归需要的参数，这里每次回溯都是操作同一个字符串，所以需要一个起始索引确定每次分割的起始位置，另外这里ip地址确定了只能分割成四个子串，所以还需要一个参数记录当前分割了多少个字串</p>
<p>确定完回溯参数后，就是终止条件，这里ip地址只能分成四段，所以可以根据层级确定当前是否应该终止</p>
<p>每一层循环都从起始索引开始往后截取子串，因为有效值是[0,255]，所以最多只需要遍历三个元素即可跳出当前循环，然后需要判断子串大小是否在区间中且没有前导0</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;String&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; path = new ArrayList&lt;&gt;();</span><br><span class="line">    public List&lt;String&gt; restoreIpAddresses(String s) &#123;</span><br><span class="line">        backTracking(s,0,0);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void backTracking(String s, int index, int level)&#123;</span><br><span class="line">        if(index&gt;=s.length())&#123;</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line">        if(level==3)&#123;</span><br><span class="line">            if(isValited(s,index,s.length()))&#123;</span><br><span class="line">                ans.add(path.get(0) + &quot;.&quot; + path.get(1) + &quot;.&quot; + path.get(2) + &quot;.&quot; + s.substring(index,s.length()));</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=1;i&lt;=3&amp;&amp;index+i&lt;=s.length();++i)&#123;</span><br><span class="line">            if(isValited(s,index,index+i))&#123;</span><br><span class="line">                path.add(s.substring(index,index+i));</span><br><span class="line">                backTracking(s,index+i,level+1);</span><br><span class="line">                path.remove(level);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean isValited(String s,int begin,int end)&#123;</span><br><span class="line">        if(end-begin==1 || (end-begin &lt;= 3 &amp;&amp; s.charAt(begin)!=&#x27;0&#x27; &amp;&amp; Integer.valueOf(s.substring(begin,end))&lt;=255))&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011253140.png" alt="image-20240409131406149"></p>
<h2 id="8-8-子集"><a href="#8-8-子集" class="headerlink" title="8.8 子集"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets/">8.8 子集</a></h2><p>思路：回溯列举出所有的情况，因为每次递归操作的都是同一个数组的元素，所以还是需要一个起始索引判断开始的位置</p>
<p>每次递归的终止条件也很容易看出来，当起始索引超过数组元素个数大小后就可以终止了</p>
<p>每层循环也只需要遍历添加起始索引后的元素即可，因为是求子集问题，所以不需要任何的剪枝</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path = new ArrayList&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123;</span><br><span class="line">        backTracking(nums,0);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    public void backTracking(int[]nums, int index)&#123;</span><br><span class="line">        ans.add(new ArrayList&lt;&gt;(path));</span><br><span class="line">        if(index&gt;=nums.length)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=index;i&lt;nums.length;++i)&#123;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            backTracking(nums,i+1);</span><br><span class="line">            path.remove(path.size()-1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011254035.png" alt="image-20240409142206661"></p>
<h2 id="8-9-子集Ⅱ"><a href="#8-9-子集Ⅱ" class="headerlink" title="8.9 子集Ⅱ"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets-ii/">8.9 子集Ⅱ</a></h2><p>思路：跟上题差不多，不过这里会出现相同的元素，并且元素相同的集合会看作是相同的自己，所以需要先对数组进行排序，然后比较是否选取了相同的元素</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path = new ArrayList&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        backTracking(nums,0);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    public void backTracking(int[]nums, int index)&#123;</span><br><span class="line">        ans.add(new ArrayList&lt;&gt;(path));</span><br><span class="line">        if(index&gt;=nums.length)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=index;i&lt;nums.length;++i)&#123;</span><br><span class="line">            if(i!=index &amp;&amp;nums[i]==nums[i-1])&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            backTracking(nums,i+1);</span><br><span class="line">            path.remove(path.size()-1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011254042.png" alt="image-20240409222739721"></p>
<h2 id="8-10-非递减子序列"><a href="#8-10-非递减子序列" class="headerlink" title="8.10 非递减子序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/non-decreasing-subsequences/">8.10 非递减子序列</a></h2><p>思路：还是回溯找到全部的情况，这里是对一个数组进行操作，所以还是需要一个起始索引记录每次开始的位置，其次每次结束的条件都是起始索引大于数组元素</p>
<p>确定完参数和终止条件之后，就要看看每次遍历的逻辑了，这里需要找到的是非递增子序列，那么每次遍历都需要找到递增的元素，那么每次遍历只需要跟路径元素中的最后一个元素比较，只要大于等于最后一个元素即可，但是这样可能会出现两个重复的元素被使用两次当成不同子序列的问题，所以还需要在每层递归中用一个set维护已经使用过的元素，如果是已经使用过的元素就直接跳过，不再使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path = new ArrayList&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; findSubsequences(int[] nums) &#123;</span><br><span class="line">        backTracking(nums,0);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    public void backTracking(int[]nums, int index)&#123;</span><br><span class="line">        if(path.size()&gt;1)&#123;</span><br><span class="line">            ans.add(new ArrayList&lt;&gt;(path));</span><br><span class="line">        &#125;</span><br><span class="line">        if(index&gt;=nums.length)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Integer&gt; set = new HashSet&lt;&gt;();</span><br><span class="line">        for(int i=index;i&lt;nums.length;++i)&#123;</span><br><span class="line">            if(set.contains(nums[i]))&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if(path.size()==0 || nums[i]&gt;=path.get(path.size()-1))&#123;</span><br><span class="line">                set.add(nums[i]);</span><br><span class="line">                path.add(nums[i]);</span><br><span class="line">                backTracking(nums,i+1);</span><br><span class="line">                path.remove(path.size()-1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011254950.png" alt="image-20240409231632071"></p>
<h2 id="8-11-全排列"><a href="#8-11-全排列" class="headerlink" title="8.11 全排列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations/">8.11 全排列</a></h2><p>思路：直接暴力全部搜索一遍，题目中说数组不含重复数字，所以每次遍历的时候，可以都当成一个新的集合，每次都从路径元素中判断是否出现过该元素，如果出现过则直接下一个，穷举出所有的情况，并借助路径元素集合去重</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path = new ArrayList&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;</span><br><span class="line">        backTracking(nums);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    public void backTracking(int[] nums)&#123;</span><br><span class="line">        if(path.size()==nums.length)&#123;</span><br><span class="line">            ans.add(new ArrayList&lt;&gt;(path));</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;nums.length;++i)&#123;</span><br><span class="line">            if(!path.contains(nums[i]))&#123;</span><br><span class="line">                path.add(nums[i]);</span><br><span class="line">                backTracking(nums);</span><br><span class="line">                path.remove(path.size()-1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011254937.png" alt="image-20240410195752215"></p>
<p>优化：上面这种思路虽然可以列举出全部的情况并且不会重复，但是每层递归使用的contains函数都要遍历一遍path，判断是否已经使用过该元素，时间复杂度一共来到O n的三次方，这里使用一个数组记录使用过的元素，可以将判断是否使用过一个元素的时间缩短到O(1)，总体的时间复杂度来到了O n的平方</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path = new ArrayList&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;</span><br><span class="line">        boolean[]used = new boolean[nums.length];</span><br><span class="line">        backTracking(nums,used);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    public void backTracking(int[] nums,boolean[] used)&#123;</span><br><span class="line">        if(path.size()==nums.length)&#123;</span><br><span class="line">            ans.add(new ArrayList&lt;&gt;(path));</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;nums.length;++i)&#123;</span><br><span class="line">            if(!used[i])&#123;</span><br><span class="line">                path.add(nums[i]);</span><br><span class="line">                used[i]=true;</span><br><span class="line">                backTracking(nums,used);</span><br><span class="line">                path.remove(path.size()-1);</span><br><span class="line">                used[i]=false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011254176.png" alt="image-20240410201523514"></p>
<h2 id="8-12-全排列Ⅱ"><a href="#8-12-全排列Ⅱ" class="headerlink" title="8.12 全排列Ⅱ"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations-ii/">8.12 全排列Ⅱ</a></h2><p>思路：跟上题的回溯差不多，可以使用一个数组记录使用过的元素减少判断元素是否使用过的情况，然后这里跟上一题不一样的地方就是数组中会出现相同的元素，要返回的是不重复的全排列，所以还需要用一个数组判断当前位置是否已经使用过某个元素，注意到这里数组中的元素范围是[-10,10]，所以可以使用一个大小为21的数组记录使用过的元素</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path = new ArrayList&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123;</span><br><span class="line">        boolean[] pathUsed = new boolean[nums.length];</span><br><span class="line">        backTracking(nums,pathUsed);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    public void backTracking(int[]nums,boolean[]pathUsed)&#123;</span><br><span class="line">        if(path.size()==nums.length)&#123;</span><br><span class="line">            ans.add(new ArrayList&lt;&gt;(path));</span><br><span class="line">        &#125;</span><br><span class="line">        boolean[] indexUsed = new boolean[21];</span><br><span class="line">        for(int i=0;i&lt;nums.length;++i)&#123;</span><br><span class="line">            if(!pathUsed[i]&amp;&amp;!indexUsed[nums[i]+10])&#123;</span><br><span class="line">                path.add(nums[i]);</span><br><span class="line">                pathUsed[i]=true;</span><br><span class="line">                indexUsed[nums[i]+10]=true;</span><br><span class="line">                backTracking(nums,pathUsed);</span><br><span class="line">                path.remove(path.size()-1);</span><br><span class="line">                pathUsed[i]=false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011254377.png" alt="image-20240410203817467"></p>
<h2 id="8-13-重新安排行程"><a href="#8-13-重新安排行程" class="headerlink" title="*8.13 重新安排行程"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reconstruct-itinerary/">*8.13 重新安排行程</a></h2><p>思路：第一想法还是回溯，dfs找到全部的路径，如果某一条路线走不通再回溯到之前的其他路线</p>
<p>先确定好递归所需要的参数，首先需要一个变量path记录走到当前位置所经过的地点，然后为了防止路程中出现环形导致在循环里出不来，这里还要用一个数组记录当前索引的地点是否已经走过</p>
<p>接下来就是确定每一层遍历的逻辑，这里每一层都需要根据上一次行程的终点找到符合条件的机票，即需要找到起点是路径中最后一处地点的并且还是未使用过的机票，找到之后递归</p>
<p>值得注意的是这里的递归并不像之前一样不需要返回参数，因为要找到一条符合条件的路，所以这里需要传回一个boolean值判断当前路径是否能够走通</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;String&gt; path = new ArrayList&lt;&gt;();</span><br><span class="line">    public List&lt;String&gt; findItinerary(List&lt;List&lt;String&gt;&gt; tickets) &#123;</span><br><span class="line">        Collections.sort(tickets,(a,b)-&gt;a.get(1).compareTo(b.get(1)));</span><br><span class="line">        boolean[]used = new boolean[tickets.size()];</span><br><span class="line">        path.add(&quot;JFK&quot;);</span><br><span class="line">        backTracking(tickets,used);</span><br><span class="line">        return path;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean backTracking(List&lt;List&lt;String&gt;&gt; tickets, boolean[] used)&#123;</span><br><span class="line">        if(path.size()==tickets.size()+1)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;tickets.size();++i)&#123;</span><br><span class="line">            if(!used[i] &amp;&amp; path.get(path.size()-1).equals(tickets.get(i).get(0)))&#123;</span><br><span class="line">                used[i]=true;</span><br><span class="line">                path.add(tickets.get(i).get(1));</span><br><span class="line"></span><br><span class="line">                if(backTracking(tickets,used))&#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">                used[i]=false;</span><br><span class="line">                path.remove(path.size()-1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011254656.png" alt="image-20240411093311543"></p>
<p>优化：上面的代码只差一个样例点没过，那么至少证明思路没有问题，那么有什么办法可以优化搜索的过程呢</p>
<p>我们注意到上面每次根据路径最后一个节点找到符合条件的机票，都要从头开始遍历全部机票并且比较起始位置和当前位置是否相同和是否使用过，这里耗费了较多时间，可以想办法对这个过程进行优化，这里使用了一个Map数组去记录一个机票的起点和他的索引的集合，这样每次找某个起点的机票只需要从map中找到key为该起点的集合，集合中的元素就是符合条件的机票的索引</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;String&gt; path = new ArrayList&lt;&gt;();</span><br><span class="line">    public List&lt;String&gt; findItinerary(List&lt;List&lt;String&gt;&gt; tickets) &#123;</span><br><span class="line">        Collections.sort(tickets,(a,b)-&gt;a.get(1).compareTo(b.get(1)));</span><br><span class="line">        boolean[]used = new boolean[tickets.size()];</span><br><span class="line">        path.add(&quot;JFK&quot;);</span><br><span class="line">        Map&lt;String,List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        for(int i=0;i&lt;tickets.size();++i)&#123;</span><br><span class="line">            List&lt;Integer&gt; list = map.getOrDefault(tickets.get(i).get(0),new ArrayList&lt;&gt;());</span><br><span class="line">            list.add(i);</span><br><span class="line">            map.put(tickets.get(i).get(0),list);</span><br><span class="line">        &#125;</span><br><span class="line">        backTracking(tickets,used,map);</span><br><span class="line">        return path;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean backTracking(List&lt;List&lt;String&gt;&gt; tickets, boolean[] used,Map&lt;String, List&lt;Integer&gt;&gt; map)&#123;</span><br><span class="line">        if(path.size()==tickets.size()+1)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if(map.containsKey(path.get(path.size()-1)))&#123;</span><br><span class="line">            for(Integer index:map.get(path.get(path.size()-1)))&#123;</span><br><span class="line">                if(!used[index])&#123;</span><br><span class="line">                    used[index]=true;</span><br><span class="line">                    path.add(tickets.get(index).get(1));</span><br><span class="line">                    if(backTracking(tickets,used,map))&#123;</span><br><span class="line">                        return true;</span><br><span class="line">                    &#125;</span><br><span class="line">                    used[index]=false;</span><br><span class="line">                    path.remove(path.size()-1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011254149.png" alt="image-20240411093918649"></p>
<p>再优化：还是这一个样例点没过，看来优化机票的搜索过程并没有优化太多的时间，这里又注意到为了在有多个符合条件的路径时找到从小到大的路径，在一开始要对机票进行排序，这个过程可能会耗费比较多的时间，还有机票的map维护的是起点机票和他的索引的映射，这里可以直接将索引改为终点字符串，这样就只需要对map进行操作，不需要再去操作数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;String&gt; path = new ArrayList&lt;&gt;();</span><br><span class="line">    Map&lt;String,List&lt;String&gt;&gt; tickerMap = new HashMap&lt;&gt;();</span><br><span class="line">    int total = 0;</span><br><span class="line">    public List&lt;String&gt; findItinerary(List&lt;List&lt;String&gt;&gt; tickets) &#123;</span><br><span class="line">        total=tickets.size();</span><br><span class="line">        path.add(&quot;JFK&quot;);</span><br><span class="line">        for(int i=0;i&lt;tickets.size();++i)&#123;</span><br><span class="line">            addNew(tickets.get(i).get(0),tickets.get(i).get(1));</span><br><span class="line">        &#125;</span><br><span class="line">        backTracking(&quot;JFK&quot;);</span><br><span class="line">        return path;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean backTracking(String start)&#123;</span><br><span class="line">        if(path.size()==total+1)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if(tickerMap.containsKey(start))&#123;</span><br><span class="line">            List&lt;String&gt; tickets = tickerMap.get(start);</span><br><span class="line">            for(int i=0;i&lt;tickets.size();++i)&#123;</span><br><span class="line">                String end = tickets.get(i);</span><br><span class="line">                path.add(end);</span><br><span class="line">                tickets.remove(i);</span><br><span class="line">                if(backTracking(end))&#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">                path.remove(path.size()-1);</span><br><span class="line">                tickets.add(i,end);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    public void addNew(String start, String end)&#123;</span><br><span class="line">        List&lt;String&gt; list = tickerMap.getOrDefault(start,new ArrayList&lt;&gt;());</span><br><span class="line">        for(int i=0;i&lt;list.size();++i)&#123;</span><br><span class="line">            if(end.compareTo(list.get(i))&lt;0)&#123;</span><br><span class="line">                list.add(i,end);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(end);</span><br><span class="line">        tickerMap.put(start,list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011254897.png" alt="image-20240411094349627"></p>
<p>结果依然还是这个点超时了，有点蚌埠住了，这里用相同的逻辑换c++试一下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">// unordered_map&lt;出发机场, map&lt;到达机场, 航班次数&gt;&gt; targets</span><br><span class="line">unordered_map&lt;string, map&lt;string, int&gt;&gt; targets;</span><br><span class="line">bool backtracking(int ticketNum, vector&lt;string&gt;&amp; result) &#123;</span><br><span class="line">    if (result.size() == ticketNum + 1) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    for (pair&lt;const string, int&gt;&amp; target : targets[result[result.size() - 1]]) &#123;</span><br><span class="line">        if (target.second &gt; 0 ) &#123; // 记录到达机场是否飞过了</span><br><span class="line">            result.push_back(target.first);</span><br><span class="line">            target.second--;</span><br><span class="line">            if (backtracking(ticketNum, result)) return true;</span><br><span class="line">            result.pop_back();</span><br><span class="line">            target.second++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; findItinerary(vector&lt;vector&lt;string&gt;&gt;&amp; tickets) &#123;</span><br><span class="line">        targets.clear();</span><br><span class="line">        vector&lt;string&gt; result;</span><br><span class="line">        for (const vector&lt;string&gt;&amp; vec : tickets) &#123;</span><br><span class="line">            targets[vec[0]][vec[1]]++; // 记录映射关系</span><br><span class="line">        &#125;</span><br><span class="line">        result.push_back(&quot;JFK&quot;); // 起始机场</span><br><span class="line">        backtracking(tickets.size(), result);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011254530.png" alt="image-20240411094443351"></p>
<p>结果非常的amazing啊，换了c++就过了</p>
<h2 id="8-14-N皇后"><a href="#8-14-N皇后" class="headerlink" title="8.14 N皇后"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/n-queens/">8.14 N皇后</a></h2><p>思路：递归遍历全部情况然后回溯，首先确定回溯的全局参数，这里需要一个path记录之前皇后放下的位置，还有一个记录符合条件的集合ans，还需要记录当前遍历到的索引的位置</p>
<p>接下来确定终止条件，因为只有n个皇后，所以遍历到第n个位置就可以停下终止</p>
<p>最后确定每一层的遍历循环条件，只需要判断当前位置是否符合要求即可，对于不同的列，只要他跟之前放的皇后行号不一样，就可以保证横竖方向不会冲突，这时候只需要解决斜向不会冲突即可，可以通过存放位置和索引之和和差进行判断是否冲突</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;Integer&gt; path = new ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123;</span><br><span class="line">        backTracking(n,0);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    public void backTracking(int n,int index)&#123;</span><br><span class="line">        if(n==index)&#123;</span><br><span class="line">            List&lt;String&gt; once = new ArrayList&lt;&gt;();</span><br><span class="line">            for(int i=0;i&lt;n;++i)&#123;</span><br><span class="line">                StringBuilder sb = new StringBuilder();</span><br><span class="line">                for(int j=0;j&lt;path.get(i);++j)&#123;</span><br><span class="line">                    sb.append(&quot;.&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                sb.append(&quot;Q&quot;);</span><br><span class="line">                for(int j=path.get(i)+1;j&lt;n;++j)&#123;</span><br><span class="line">                    sb.append(&quot;.&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                once.add(sb.toString());</span><br><span class="line">            &#125;</span><br><span class="line">            ans.add(once);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;n;++i)&#123;</span><br><span class="line">            if(isValidated(i,index))&#123;</span><br><span class="line">                path.add(i);</span><br><span class="line">                backTracking(n,index+1);</span><br><span class="line">                path.remove(path.size()-1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean isValidated(int position,int index)&#123;</span><br><span class="line">        for(int i=0;i&lt;path.size();++i)&#123;</span><br><span class="line">            if(path.get(i)==position || path.get(i)-i==position-index || path.get(i)+i==position+index)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011254976.png" alt="image-20240411120357611"></p>
<p>优化：用char二维数组代替字符串的拼接，减少对字符串操作耗费的时间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123;</span><br><span class="line">        char[][] chessBoard=  new char[n][n];</span><br><span class="line">        for (char[] c : chessBoard) &#123;</span><br><span class="line">            Arrays.fill(c, &#x27;.&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">        backTracking(n,0,chessBoard);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    public void backTracking(int n,int index,char[][]chessBoard)&#123;</span><br><span class="line">        if(n==index)&#123;</span><br><span class="line">            List&lt;String&gt; once = new ArrayList&lt;&gt;();</span><br><span class="line">            for(int i=0;i&lt;n;++i)&#123;</span><br><span class="line">                once.add(new String(chessBoard[i]));</span><br><span class="line">            &#125;</span><br><span class="line">            ans.add(once);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;n;++i)&#123;</span><br><span class="line">            if(isValidated(i,index,chessBoard))&#123;</span><br><span class="line">                chessBoard[i][index]=&#x27;Q&#x27;;</span><br><span class="line">                backTracking(n,index+1,chessBoard);</span><br><span class="line">                chessBoard[i][index]=&#x27;.&#x27;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean isValidated(int position,int index,char[][]chessBoard)&#123;</span><br><span class="line">        for(int i=0;i&lt;chessBoard.length;++i)&#123;</span><br><span class="line">            if(chessBoard[position][i]==&#x27;Q&#x27;)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int add=position+index;</span><br><span class="line">        int minus=position-index;</span><br><span class="line">        for(int i=0;i&lt;chessBoard.length;++i)&#123;</span><br><span class="line">            int addTem = add-i;</span><br><span class="line">            int minusTem = minus+i;</span><br><span class="line">            if(addTem&gt;=0 &amp;&amp; addTem&lt;chessBoard.length &amp;&amp; chessBoard[addTem][i]==&#x27;Q&#x27;)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            if(minusTem&gt;=0&amp;&amp;minus+i&lt;chessBoard.length &amp;&amp;chessBoard[minusTem][i]==&#x27;Q&#x27;)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011254494.png" alt="image-20240411140438334"></p>
<h2 id="8-15-解数独"><a href="#8-15-解数独" class="headerlink" title="8.15 解数独"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sudoku-solver/">8.15 解数独</a></h2><p>思路：还是穷举出所有的情况，如果不正确就回溯更换其他数字，这里还是需要返回一个boolean值判断当前情况是否符合条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void solveSudoku(char[][] board) &#123;</span><br><span class="line">        solveSudokuHelper(board);</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean solveSudokuHelper(char[][] board)&#123;</span><br><span class="line">        for(int i=0;i&lt;board.length;++i)&#123;</span><br><span class="line">            for(int j=0;j&lt;board.length;++j)&#123;</span><br><span class="line">                if(board[i][j]!=&#x27;.&#x27;)&#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                for(char k=&#x27;1&#x27;;k&lt;=&#x27;9&#x27;;++k)&#123;</span><br><span class="line">                    if(isValidated(board,i,j,k))&#123;</span><br><span class="line">                        board[i][j]=k;</span><br><span class="line">                        if(solveSudokuHelper(board))&#123;</span><br><span class="line">                            return true;</span><br><span class="line">                        &#125;</span><br><span class="line">                        board[i][j]=&#x27;.&#x27;;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean isValidated(char[][]board, int i,int j,char k)&#123;</span><br><span class="line">        for(int m=0;m&lt;board.length;++m)&#123;</span><br><span class="line">            if(board[i][m]==k || board[m][j]==k)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        i=i/3*3;</span><br><span class="line">        j=j/3*3;</span><br><span class="line">        for(int m=i;m&lt;3+i;++m)&#123;</span><br><span class="line">            for(int n=j;n&lt;3+j;++n)&#123;</span><br><span class="line">               if(board[m][n]==k)&#123;</span><br><span class="line">                return false;</span><br><span class="line">               &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011255309.png" alt="image-20240411145232802"></p>
<h1 id="9-贪心算法"><a href="#9-贪心算法" class="headerlink" title="9.贪心算法"></a>9.贪心算法</h1><h2 id="9-1分发饼干"><a href="#9-1分发饼干" class="headerlink" title="9.1分发饼干"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/assign-cookies/">9.1分发饼干</a></h2><p>思路：既然要尽可能满足越多数量的孩子，那么就要减少饼干的浪费，小的饼干能满足小胃口的孩子，就不要浪费大的饼干，先对孩子胃口和饼干大小排序，从小到大遍历饼干，寻找是否能满足剩余最小胃口的小孩</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int findContentChildren(int[] g, int[] s) &#123;</span><br><span class="line">        Arrays.sort(g);</span><br><span class="line">        Arrays.sort(s);</span><br><span class="line">        int a=0;</span><br><span class="line">        int cnt=0;</span><br><span class="line">        for(int i=0;i&lt;s.length;i++)&#123;</span><br><span class="line">            if(s[i]&gt;=g[a])&#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">                ++a;</span><br><span class="line">                if(a&gt;=g.length)&#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011255232.png" alt="image-20240203205405400"></p>
<h2 id="9-2摆动序列"><a href="#9-2摆动序列" class="headerlink" title="9.2摆动序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/wiggle-subsequence/">9.2摆动序列</a></h2><p>思路：这题要注意的点比较多，首先是差值等于0不算摆动系列，所以cur等于0的情况不需要管。还有要注意头尾的元素也要计算摆动，还有单调的平坡不能重复计算，所以只需要在坡度变化的情况下改变pre就可以了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int wiggleMaxLength(int[] nums) &#123;</span><br><span class="line">        if(nums.length==1)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        int pre=0;</span><br><span class="line">        int cur=0;</span><br><span class="line">        int cnt=1;</span><br><span class="line">        for(int i =0;i&lt;nums.length-1;i++)&#123;</span><br><span class="line">            cur=nums[i+1]-nums[i];</span><br><span class="line">            if((pre&lt;=0&amp;&amp;cur&gt;0)||(pre&gt;=0&amp;&amp;cur&lt;0))&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                pre=cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return cnt; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011255283.png" alt="image-20240203213937224"></p>
<h2 id="9-3最大子序和"><a href="#9-3最大子序和" class="headerlink" title="9.3最大子序和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray/">9.3最大子序和</a></h2><p>思路：第一眼看上去要找子数组最大感觉要用双指针维护一个滑动窗口，但是仔细一想，滑动窗口其实还不太能做这道题，因为很难保证快指针遇到负数之后后面不会有更大的数，所以想到了动态规划，创建了一个数组dp[i]，保证原数组从0到i至少包含一个元素的最大子序和为dp[i]</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxSubArray(int[] nums) &#123;</span><br><span class="line">        int[] dp=new int[nums.length];</span><br><span class="line">        dp[0]=nums[0];</span><br><span class="line">        int ans=dp[0];</span><br><span class="line">        for(int i=1;i&lt;nums.length;i++)&#123;</span><br><span class="line">            dp[i]=Math.max(0,dp[i-1])+nums[i];</span><br><span class="line">            ans=Math.max(dp[i],ans);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面只有一次遍历，其实可以把dp数组优化掉，其实也像是贪心算法，pre是从0到指针处的最大数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxSubArray(int[] nums) &#123;</span><br><span class="line">        int ans=nums[0];</span><br><span class="line">        int pre=nums[0];</span><br><span class="line">        for(int i=1;i&lt;nums.length;i++)&#123;</span><br><span class="line">            pre=Math.max(0,pre)+nums[i];</span><br><span class="line">            ans=Math.max(pre,ans);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011255750.png" alt="image-20240203231652455"></p>
<h2 id="9-4买卖股票的最佳时机Ⅱ"><a href="#9-4买卖股票的最佳时机Ⅱ" class="headerlink" title="9.4买卖股票的最佳时机Ⅱ"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">9.4买卖股票的最佳时机Ⅱ</a></h2><p>思路：最不用动脑的一题，只要下一天股票涨了我就买，只要跌了我就卖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxProfit(int[] prices) &#123;</span><br><span class="line">        int ans=0;</span><br><span class="line">        for(int i=1;i&lt;prices.length;i++)&#123;</span><br><span class="line">            ans+=Math.max(prices[i]-prices[i-1],0);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011255574.png" alt="image-20240203232552825"></p>
<h2 id="9-5跳跃游戏"><a href="#9-5跳跃游戏" class="headerlink" title="9.5跳跃游戏"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/jump-game/">9.5跳跃游戏</a></h2><p>思路：抽象成数学问题贪心算法其实挺好做的，只是一些特例比较恶心卡了我几次。</p>
<p>首先要明确不是所在位置元素有多大就一定要跳多远，即使数字很大我也可以只跳一格，那么我们就可以把跳跃这个行为抽象成一种能力，一个我还能往后走多少格的能力，所以每往后走一格我的这个能力就会-1，但是我可以选择跳到这个格子里，那么我的能力清零但是我获得大小等于这个数字的能力，贪心算法保证我的能力一直是最大的，如果某一时刻为0但是还没到结尾那么就不能到达</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean canJump(int[] nums) &#123;</span><br><span class="line">    	//长度为一就在数组结尾</span><br><span class="line">        if(nums.length==1)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        //开头就不能跳而且不是长度为一直接返回false</span><br><span class="line">        if(nums[0]==0)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        int cur=nums[0];</span><br><span class="line">        for(int i=1;i&lt;nums.length;i++)&#123;</span><br><span class="line">            cur=Math.max(cur-1,nums[i]);</span><br><span class="line">            if(cur&lt;=0&amp;&amp;i&lt;nums.length-1)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011255031.png" alt="image-20240203234221010"></p>
<h2 id="9-6跳跃游戏Ⅱ"><a href="#9-6跳跃游戏Ⅱ" class="headerlink" title="9.6跳跃游戏Ⅱ"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/jump-game-ii/">9.6跳跃游戏Ⅱ</a></h2><p>思路：因为题目保证了最后一个节点一定可达，所以只需要计算最小跳跃次数就行，这里创建了一个数组，代表从头到当前索引位置的最小跳跃次数，每次往后一格都计算从当前格往后跳最小跳跃的次数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int jump(int[] nums) &#123;</span><br><span class="line">        int[] dp = new int[nums.length];</span><br><span class="line">        for(int i=1;i&lt;dp.length;i++)&#123;</span><br><span class="line">            dp[i]=Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;nums.length;i++)&#123;</span><br><span class="line">            for(int j=1;j&lt;=nums[i];j++)&#123;</span><br><span class="line">                if(i+j&lt;nums.length)&#123;</span><br><span class="line">                    dp[i+j]=Math.min(dp[i+j],dp[i]+1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[nums.length-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011255970.png" alt="image-20240204000609450"></p>
<p>虽然过了但是非常丑陋，耗时也很长，想一下还有什么办法，遍历数组的时候每到一个位置都要往他可达的地方刷新一遍最小步数，其实很浪费时间，其实只需要用覆盖范围的概念，找到可达范围内的覆盖范围最大的位置即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int jump(int[] nums) &#123;</span><br><span class="line">        if(nums.length==1)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int cnt=1;</span><br><span class="line">        int cover=nums[0];</span><br><span class="line">        int next=cover;</span><br><span class="line">        int end=nums.length-1;</span><br><span class="line">        int cur=0;</span><br><span class="line">        while(cover&lt;end)&#123;</span><br><span class="line">            for(int i=cur+1;i&lt;=cover;i++)&#123;</span><br><span class="line">                if(next&lt;end&amp;&amp;i+nums[i]&gt;cover)&#123;</span><br><span class="line">                    next=Math.max(i+nums[i],next);</span><br><span class="line">                    cur=i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cover=next;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        return cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011255084.png" alt="image-20240204003420389"></p>
<p>看了题解后发现其实只用一层循环就可以解决了，不过思路差不多，时间复杂度也一样，但是太优雅了</p>
<h2 id="9-7K次取反后最大化的数组和"><a href="#9-7K次取反后最大化的数组和" class="headerlink" title="9.7K次取反后最大化的数组和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/">9.7K次取反后最大化的数组和</a></h2><p>思路：每次都找到最小的一个数取反</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int largestSumAfterKNegations(int[] nums, int k) &#123;</span><br><span class="line">        int min=0;</span><br><span class="line">        while(k&gt;0)&#123;</span><br><span class="line">            for(int i=0;i&lt;nums.length;i++)&#123;</span><br><span class="line">                if(nums[min]&gt;nums[i])&#123;</span><br><span class="line">                    min=i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(nums[min]&gt;=0)&#123;</span><br><span class="line">                k=k%2;</span><br><span class="line">            &#125;</span><br><span class="line">            if(k&gt;0)&#123;</span><br><span class="line">                nums[min]=-nums[min];</span><br><span class="line">                --k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int sum=0;</span><br><span class="line">        for(int i=0;i&lt;nums.length;++i)&#123;</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011255465.png" alt="image-20240204133305345"></p>
<p>但是耗时较长，可以先对数组排序，然后一直取反直到遇到非负数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int largestSumAfterKNegations(int[] nums, int k) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        int sum=0;</span><br><span class="line">        for(int i=0;i&lt;nums.length;++i)&#123;</span><br><span class="line">            if(nums[i]&gt;=0)&#123;</span><br><span class="line">                k%=2;</span><br><span class="line">            &#125;</span><br><span class="line">            if(k&gt;0)&#123;</span><br><span class="line">                nums[i]=-nums[i];</span><br><span class="line">                --k;</span><br><span class="line">            &#125;</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011255436.png" alt="image-20240204135333936"></p>
<p>还是没过，推测是因为将-2变为2后k等于1，然后继续往后把4变成-4了，然后交了一次，还有k大于数组个数的情况，最终修改通过代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int largestSumAfterKNegations(int[] nums, int k) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        int sum=0;</span><br><span class="line">        for(int i=0;i&lt;nums.length;++i)&#123;</span><br><span class="line">            if(nums[i]&gt;=0)&#123;</span><br><span class="line">                k%=2;</span><br><span class="line">                //如果还要选一个做负数</span><br><span class="line">                if(k==1)&#123;</span><br><span class="line">                    //如果不是第一个元素并且上一个元素绝对值小</span><br><span class="line">                    if(i!=0&amp;&amp;nums[i-1]&lt;nums[i])&#123;</span><br><span class="line">                        sum-=(2*nums[i-1]);</span><br><span class="line">                        --k;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(k&gt;0)&#123;</span><br><span class="line">                nums[i]=-nums[i];</span><br><span class="line">                --k;</span><br><span class="line">            &#125;</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        if(k&gt;0&amp;&amp;k%2==1)&#123;</span><br><span class="line">            int min=Integer.MAX_VALUE;</span><br><span class="line">            for(int i=0;i&lt;nums.length;++i)&#123;</span><br><span class="line">                min=Math.min(min,nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            sum-=(2*min);</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011256658.png" alt="image-20240204140206785"></p>
<h2 id="9-8加油站"><a href="#9-8加油站" class="headerlink" title="9.8加油站"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/gas-station/">9.8加油站</a></h2><p>思路：首先我们假设他可以绕行一周，计算从0开始到下一个位置剩下的油，如果到最后油量为负数，那么说明不能绕行一周，那么在保证可以绕行一周后怎么确定起点呢。</p>
<p>这个时候只需要找到过程中油量最少的索引即可，我们从开头的油量设为0，这个0只是相对值，并不会像真实场景那样没油了就会停下来，在遍历往下后到达下一个地点还剩多少油，找到油最少的情况，就能够保证其他所有时刻油量都大于等于0</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int canCompleteCircuit(int[] gas, int[] cost) &#123;</span><br><span class="line">        int min=Integer.MAX_VALUE;</span><br><span class="line">        int index=0;</span><br><span class="line">        int cur=0;</span><br><span class="line">        for(int i=0;i&lt;gas.length;++i)&#123;</span><br><span class="line">            cur+=(gas[i]-cost[i]);</span><br><span class="line">            if(cur&lt;=min)&#123;</span><br><span class="line">                min=cur;</span><br><span class="line">                index=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(cur&lt;0)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        return (index+1)%gas.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011256472.png" alt="image-20240204144948662"></p>
<h2 id="9-9分发糖果"><a href="#9-9分发糖果" class="headerlink" title="*9.9分发糖果"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/candy/">*9.9分发糖果</a></h2><p>思路：一开始一直在想怎么让糖果最少，但是忽略找到局部最优，后来看了其他人的思路才想到，分别从左右两边寻找最少，从而让局部最优变成整体最优</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int candy(int[] ratings) &#123;</span><br><span class="line">        int[] candies=new int[ratings.length];</span><br><span class="line">        candies[0]=1;</span><br><span class="line">        for(int i=1;i&lt;ratings.length;++i)&#123;</span><br><span class="line">            if(ratings[i]&gt;ratings[i-1])&#123;</span><br><span class="line">                candies[i]=candies[i-1]+1;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                candies[i]=1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int sum=0;</span><br><span class="line">        for(int i=ratings.length-1;i&gt;0;--i)&#123;</span><br><span class="line">            if(ratings[i-1]&gt;ratings[i])&#123;</span><br><span class="line">                candies[i-1]=Math.max(candies[i]+1,candies[i-1]);</span><br><span class="line">            &#125;</span><br><span class="line">            sum+=candies[i];</span><br><span class="line">        &#125;</span><br><span class="line">        sum+=candies[0];</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011256817.png" alt="image-20240204154324511"></p>
<h2 id="9-10柠檬水找零"><a href="#9-10柠檬水找零" class="headerlink" title="9.10柠檬水找零"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lemonade-change/">9.10柠檬水找零</a></h2><p>思路：按流程模拟一遍就行了，记录当前剩余的5元和10元，如果顾客付5元不用找，10元只能找5元，20元可以找三张5元或10元和5元各一张，只有20元可以找10元，所以优先找10元</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean lemonadeChange(int[] bills) &#123;</span><br><span class="line">        int five=0;</span><br><span class="line">        int ten=0;</span><br><span class="line">        for(int i=0;i&lt;bills.length;++i)&#123;</span><br><span class="line">            if(bills[i]==5)&#123;</span><br><span class="line">                //5元不用找</span><br><span class="line">                ++five;</span><br><span class="line">            &#125;else if (bills[i]==10)&#123;</span><br><span class="line">                //10元找五元</span><br><span class="line">                --five;</span><br><span class="line">                ++ten;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                //20元优先找10元</span><br><span class="line">                if(ten&gt;0)&#123;</span><br><span class="line">                    --ten;</span><br><span class="line">                    --five;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    five=five-3;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(five&lt;0||ten&lt;0)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011256945.png" alt="image-20240204155133649"></p>
<h2 id="9-11根据身高重建队列"><a href="#9-11根据身高重建队列" class="headerlink" title="*9.11根据身高重建队列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/queue-reconstruction-by-height/">*9.11根据身高重建队列</a></h2><p>思路：第一时间想到的是根据排名先排序，后面再移动身高，但是这样的方法要归纳出一个方法还是比较困难，所以还是得先用身高排序，然后再根据k值往后移动</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[][] reconstructQueue(int[][] people) &#123;</span><br><span class="line">        Arrays.sort(people,(p1,p2)-&gt;&#123;</span><br><span class="line">            return p1[0]-p2[0] == 0 ?</span><br><span class="line">                        p2[1]-p1[1]:</span><br><span class="line">                        p1[0]-p2[0];</span><br><span class="line">        &#125;);</span><br><span class="line">        for(int i=people.length-1;i&gt;=0;--i)&#123;</span><br><span class="line">            if(people[i][1]&gt;0)&#123;</span><br><span class="line">                int tem1=people[i][0];</span><br><span class="line">                int tem2=people[i][1];</span><br><span class="line">                for(int j=0;j&lt;tem2;++j)&#123;</span><br><span class="line">                    people[i+j][0]=people[i+j+1][0];</span><br><span class="line">                    people[i+j][1]=people[i+j+1][1];</span><br><span class="line">                &#125;</span><br><span class="line">                people[i+tem2][0]=tem1;</span><br><span class="line">                people[i+tem2][1]=tem2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return people;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011256771.png" alt="image-20240204164549775"></p>
<p>但是耗时有点抽象，主要是移动耗了很多时间，这里可以先反向排序，然后用LinkedList插入重排序转回数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[][] reconstructQueue(int[][] people) &#123;</span><br><span class="line">        Arrays.sort(people,(p1,p2)-&gt;&#123;</span><br><span class="line">            return p1[0]-p2[0] == 0 ?</span><br><span class="line">                        p1[1]-p2[1]:</span><br><span class="line">                        p2[0]-p1[0];</span><br><span class="line">        &#125;);</span><br><span class="line">        List&lt;int[]&gt; list=new ArrayList&lt;&gt;();</span><br><span class="line">        for(int[] p:people)&#123;</span><br><span class="line">            list.add(p[1],p);</span><br><span class="line">        &#125;</span><br><span class="line">        return list.toArray(new int[people.length][2]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011256707.png" alt="image-20240204170404380"></p>
<h2 id="9-12用最少数量的箭引爆气球"><a href="#9-12用最少数量的箭引爆气球" class="headerlink" title="9.12用最少数量的箭引爆气球"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/">9.12用最少数量的箭引爆气球</a></h2><p>思路：一看到这道题的直觉就是要每支箭都尽可能多的去射到多的气球，但是要模拟出这个情况还是想了很久的，可以先将数组排序，然后确保下一个气球的左边界不回超过前面气球最小右边界就可以了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int findMinArrowShots(int[][] points) &#123;</span><br><span class="line">        Arrays.sort(points, (p1,p2)-&gt;&#123;</span><br><span class="line">            if( p1[0]-p2[0]==0)&#123;</span><br><span class="line">                return Integer.compare(p1[1],p2[1]);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return Integer.compare(p1[0],p2[0]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        int cnt=1;</span><br><span class="line">        int right=points[0][1];</span><br><span class="line">        for(int i=0;i&lt;points.length;++i)&#123;</span><br><span class="line">            if(points[i][0]&gt;right)&#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">                right=points[i][1];</span><br><span class="line">            &#125;</span><br><span class="line">            right=Math.min(right,points[i][1]);</span><br><span class="line">        &#125;</span><br><span class="line">        return cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011256485.png" alt="image-20240204180315568"></p>
<h2 id="9-13无重叠区间"><a href="#9-13无重叠区间" class="headerlink" title="9.13无重叠区间"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/non-overlapping-intervals/">9.13无重叠区间</a></h2><p>思路：跟上题引爆气球思路差不多，都是找重复的区间，但是我这里是按右排序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int eraseOverlapIntervals(int[][] intervals) &#123;</span><br><span class="line">        Arrays.sort(intervals,(i1,i2)-&gt;&#123;</span><br><span class="line">            if(i1[1]==i2[1])&#123;</span><br><span class="line">                return Integer.compare(i2[0],i1[0]);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return Integer.compare(i1[1],i2[1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        int cnt=0;</span><br><span class="line">        int pre=0;</span><br><span class="line">        for(int i=1;i&lt;intervals.length;++i)&#123;</span><br><span class="line">            if(intervals[i][1]==intervals[i-1][1])&#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;else if(intervals[i][0]&lt;intervals[pre][1])&#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                pre=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011256121.png" alt="image-20240204194453438"></p>
<p>这里看到一个左排序的，代码量少很多，可以品一下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int eraseOverlapIntervals(int[][] intervals) &#123;</span><br><span class="line">        Arrays.sort(intervals, (a,b)-&gt; &#123;</span><br><span class="line">            return Integer.compare(a[0],b[0]);</span><br><span class="line">        &#125;);</span><br><span class="line">        int count = 1;</span><br><span class="line">        for(int i = 1;i &lt; intervals.length;i++)&#123;</span><br><span class="line">            if(intervals[i][0] &lt; intervals[i-1][1])&#123;</span><br><span class="line">                intervals[i][1] = Math.min(intervals[i - 1][1], intervals[i][1]);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">        return intervals.length - count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-14划分字母区间"><a href="#9-14划分字母区间" class="headerlink" title="9.14划分字母区间"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-labels/">9.14划分字母区间</a></h2><p>思路：暴力循环，遍历整个字符串，找到开头字符最后出现的位置，然后把开头到整个位置之间的全部字符最后出现的位置找到，重复此操作，直到保证区间内全部元素都不出现在区间外，继续完成整个字符串的遍历</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; partitionLabels(String s) &#123;</span><br><span class="line">        Set&lt;Character&gt; set = new HashSet&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; ans =new ArrayList&lt;&gt;();</span><br><span class="line">        int start=0;</span><br><span class="line">        int cur=0;</span><br><span class="line">        int end=1;</span><br><span class="line">        while(end&lt;=s.length())&#123;</span><br><span class="line">            while(cur&lt;end)&#123;</span><br><span class="line">                set.add(s.charAt(cur));</span><br><span class="line">                for(int i=cur+1;i&lt;s.length();++i)&#123;</span><br><span class="line">                    if(s.charAt(i)==s.charAt(cur))&#123;</span><br><span class="line">                        end=Math.max(i+1,end);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                do&#123;</span><br><span class="line">                    ++cur;</span><br><span class="line">                &#125;while(cur&lt;end&amp;&amp;set.contains(s.charAt(cur)));</span><br><span class="line">            &#125;</span><br><span class="line">            ans.add(end-start);</span><br><span class="line">            start=cur;</span><br><span class="line">            end=start+1;</span><br><span class="line">            set.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011256875.png" alt="image-20240204213452369"></p>
<p>这题还可以用桶排思想，记录每个字符最后出现的位置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; partitionLabels(String s) &#123;</span><br><span class="line">        List&lt;Integer&gt; ans =new ArrayList&lt;&gt;();</span><br><span class="line">        int[] edges = new int[26];</span><br><span class="line">        for(int i=0;i&lt;s.length();++i)&#123;</span><br><span class="line">            edges[s.charAt(i)-&#x27;a&#x27;]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        int start = 0;</span><br><span class="line">        int end=0;</span><br><span class="line">        for(int i=0;i&lt;s.length();++i)&#123;</span><br><span class="line">            end=Math.max(end,edges[s.charAt(i)-&#x27;a&#x27;]);</span><br><span class="line">            if(i==end)&#123;</span><br><span class="line">                ans.add(i-start+1);</span><br><span class="line">                start=i+1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011256004.png" alt="image-20240204215046423"></p>
<h2 id="9-15合并区间"><a href="#9-15合并区间" class="headerlink" title="9.15合并区间"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-intervals/">9.15合并区间</a></h2><p>思路：跟前面差不多，都是先排序，找公共区间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[][] merge(int[][] intervals) &#123;</span><br><span class="line">        Arrays.sort(intervals,(i1,i2)-&gt;&#123;</span><br><span class="line">            return Integer.compare(i1[0],i2[0]);</span><br><span class="line">        &#125;);</span><br><span class="line">        List&lt;int[]&gt;ans=new ArrayList&lt;&gt;();</span><br><span class="line">        int start=intervals[0][0];</span><br><span class="line">        int end=intervals[0][1];</span><br><span class="line">        for(int i=1;i&lt;intervals.length;++i)&#123;</span><br><span class="line">            if(intervals[i][0]&gt;end)&#123;</span><br><span class="line">                ans.add(new int[]&#123;start,end&#125;);</span><br><span class="line">                start=intervals[i][0];</span><br><span class="line">                end=intervals[i][1];</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                end=Math.max(end,intervals[i][1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.add(new int[]&#123;start,end&#125;);</span><br><span class="line">        return ans.toArray(new int[ans.size()][2]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011256399.png" alt="image-20240205224531444"></p>
<h2 id="9-16单调递增的数字"><a href="#9-16单调递增的数字" class="headerlink" title="9.16单调递增的数字"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/monotone-increasing-digits/">9.16单调递增的数字</a></h2><p>思路：纯数学，从个位开始往前走，如果前一位比后一位数字大，那么就不是递增，该位数字就要减1，低位的数字为了最大那就全都为9</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int monotoneIncreasingDigits(int n) &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        int m=n;</span><br><span class="line">        int cnt=0;</span><br><span class="line">        int pre=9;</span><br><span class="line">        while(m&gt;0)&#123;</span><br><span class="line">            int cur=m%10;</span><br><span class="line">            if(cur&gt;pre)&#123;</span><br><span class="line">                cnt=1;</span><br><span class="line">                stack.push(cur-1);</span><br><span class="line">                pre=cur-1;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                pre=cur;</span><br><span class="line">            &#125;</span><br><span class="line">            m/=10;</span><br><span class="line">        &#125;</span><br><span class="line">        int res=0;</span><br><span class="line">        for(int i=stack.size();i&gt;0;--i)&#123;</span><br><span class="line">            if(cnt&gt;0)&#123;</span><br><span class="line">                res=res*10+stack.pop();</span><br><span class="line">                --cnt;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                res=res*10+9;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011256454.png" alt="image-20240205232701539"></p>
<h2 id="9-17监控二叉树"><a href="#9-17监控二叉树" class="headerlink" title="9.17监控二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-cameras/">9.17监控二叉树</a></h2><p>思路：这题可以使用贪心算法，从叶子节点往上遍历，判断是否需要添加摄像头，节点分为三种情况，带摄像头，被监控和未被监控，分别用1，2，0表示，从叶子节点往上遍历，当子节点中存在未被监控的节点时，那么该节点一定要带摄像头，当子节点已被监控，那么该节点可以不需要带摄像头，可以返回0让父节点带摄像头保证节点被监控到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode() &#123;&#125;</span><br><span class="line"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="line"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="line"> *         this.val = val;</span><br><span class="line"> *         this.left = left;</span><br><span class="line"> *         this.right = right;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    //1 有摄像头，2被覆盖</span><br><span class="line">    private Integer cnt = 0;</span><br><span class="line">    public int minCameraCover(TreeNode root) &#123;</span><br><span class="line">        if(minCnt(root)==0)&#123;</span><br><span class="line">            ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        return cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    public int minCnt(TreeNode root)&#123;</span><br><span class="line">        if(root==null)&#123;</span><br><span class="line">            return 2;</span><br><span class="line">        &#125;</span><br><span class="line">        int left = minCnt(root.left);</span><br><span class="line">        int right = minCnt(root.right);</span><br><span class="line">        if(left==0||right==0)&#123;</span><br><span class="line">            ++cnt;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if(left==1||right==1)&#123;</span><br><span class="line">            return 2;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011256866.png" alt="image-20240314144950569"></p>
<h1 id="10-动态规划"><a href="#10-动态规划" class="headerlink" title="10.动态规划"></a>10.动态规划</h1><h2 id="10-1斐波那契数列"><a href="#10-1斐波那契数列" class="headerlink" title="10.1斐波那契数列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/fibonacci-number/">10.1斐波那契数列</a></h2><p>思路：经典问题，递归的入门，但是递归多了很多不必要的计算，所以用数组把已经计算过的数存起来，直接取就行了，从前面的状态推出后面的状态</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int fib(int n) &#123;</span><br><span class="line">        if(n==0||n==1)&#123;</span><br><span class="line">            return n;</span><br><span class="line">        &#125;</span><br><span class="line">        int[]a=new int[n+1];</span><br><span class="line">        a[0]=0;</span><br><span class="line">        a[1]=1;</span><br><span class="line">        for(int i=2;i&lt;=n;++i)&#123;</span><br><span class="line">            a[i]=a[i-1]+a[i-2];</span><br><span class="line">        &#125;</span><br><span class="line">        return a[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011257924.png" alt="image-20240205233934697"></p>
<h2 id="10-2爬楼梯"><a href="#10-2爬楼梯" class="headerlink" title="10.2爬楼梯"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/climbing-stairs/">10.2爬楼梯</a></h2><p>思路：又是一个经典问题，到一阶楼梯的方法等于到他的前一阶楼梯方法数加上前两阶方法数的和，根据前面状态推出后面状态即可，这里我采用的是从尾到头开始推</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int climbStairs(int n) &#123;</span><br><span class="line">        if(n==1)&#123;</span><br><span class="line">            return n;</span><br><span class="line">        &#125;</span><br><span class="line">        int[]dp=new int[n+1];</span><br><span class="line">        dp[n]=1;</span><br><span class="line">        dp[n-1]=1;</span><br><span class="line">        for(int i=n-2;i&gt;=0;--i)&#123;</span><br><span class="line">            dp[i]=dp[i+1]+dp[i+2];</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011257676.png" alt="image-20240209161410003"></p>
<h2 id="10-3使用最小花费爬楼梯"><a href="#10-3使用最小花费爬楼梯" class="headerlink" title="10.3使用最小花费爬楼梯"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/min-cost-climbing-stairs/">10.3使用最小花费爬楼梯</a></h2><p>思路：用前一个状态推出后一个状态，注意要跨过整个楼梯，所以最后一阶楼梯可以不踩</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int minCostClimbingStairs(int[] cost) &#123;</span><br><span class="line">        int[]dp=new int[cost.length+1];</span><br><span class="line">        dp[0]=cost[0];</span><br><span class="line">        dp[1]=cost[1];</span><br><span class="line">        for(int i=2;i&lt;=cost.length;++i)&#123;</span><br><span class="line">            dp[i]=Math.min(dp[i-1],dp[i-2]);</span><br><span class="line">            if(i&lt;cost.length)&#123;</span><br><span class="line">                dp[i]+=cost[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[cost.length];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011257966.png" alt="image-20240205235354837"></p>
<h2 id="10-4不同路径"><a href="#10-4不同路径" class="headerlink" title="10.4不同路径"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths/">10.4不同路径</a></h2><p>思路：二维数组计算到当前点的路径数，由于只能向右或向下，所以只需要加上左边和上边路径数就是到该点的路径数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int uniquePaths(int m, int n) &#123;</span><br><span class="line">        int[][]dp=new int[m][n];</span><br><span class="line">        dp[0][0]=1;</span><br><span class="line">        for(int i=0;i&lt;m;++i)&#123;</span><br><span class="line">            for(int j=0;j&lt;n;++j)&#123;</span><br><span class="line">                if(i&gt;0)&#123;</span><br><span class="line">                    dp[i][j]+=dp[i-1][j];</span><br><span class="line">                &#125;</span><br><span class="line">                if(j&gt;0)&#123;</span><br><span class="line">                    dp[i][j]+=dp[i][j-1];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[m-1][n-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011257230.png" alt="image-20240206000300782"></p>
<h2 id="10-5不同路径Ⅱ"><a href="#10-5不同路径Ⅱ" class="headerlink" title="10.5不同路径Ⅱ"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths-ii/">10.5不同路径Ⅱ</a></h2><p>思路：跟上题可以说是一模一样，代码都是直接超过去改的，不过有一个特例是地图只有障碍物，出生点都不能站</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123;</span><br><span class="line">        if(obstacleGrid[0][0]==1)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int m=obstacleGrid.length;</span><br><span class="line">        int n=obstacleGrid[0].length;</span><br><span class="line">        int[][]dp=new int[m][n];</span><br><span class="line">        dp[0][0]=1;</span><br><span class="line">        for(int i=0;i&lt;m;++i)&#123;</span><br><span class="line">            for(int j=0;j&lt;n;++j)&#123;</span><br><span class="line">                if(obstacleGrid[i][j]==1)&#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if(i&gt;0)&#123;</span><br><span class="line">                    dp[i][j]+=dp[i-1][j];</span><br><span class="line">                &#125;</span><br><span class="line">                if(j&gt;0)&#123;</span><br><span class="line">                    dp[i][j]+=dp[i][j-1];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[m-1][n-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011257337.png" alt="image-20240206000813145"></p>
<h2 id="10-6整数拆分"><a href="#10-6整数拆分" class="headerlink" title="10.6整数拆分"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/integer-break/">10.6整数拆分</a></h2><p>思路：纯数学思维，乘3是最有性价比的，简单试了一下，没想到过了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int integerBreak(int n) &#123;</span><br><span class="line">        if(n==2)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if(n==3)&#123;</span><br><span class="line">            return 2;</span><br><span class="line">        &#125;</span><br><span class="line">        int cnt=1;</span><br><span class="line">        while(n&gt;=2)&#123;</span><br><span class="line">            if(n==4)&#123;</span><br><span class="line">                n-=4;</span><br><span class="line">                cnt*=4;</span><br><span class="line">            &#125;else if(n&gt;=3)&#123;</span><br><span class="line">                n-=3;</span><br><span class="line">                cnt*=3;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                cnt*=n;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011257505.png" alt="image-20240214163400217"></p>
<p>也可以用动态规划做，这里的dp[i]表示的是当n&#x3D;i的最大乘积，每次拆分要做两次判断，是拆分两个数还是两个数以上</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int integerBreak(int n) &#123;</span><br><span class="line">        if(n==2)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        int[] dp=new int[n+1];</span><br><span class="line">        dp[1]=1;</span><br><span class="line">        dp[2]=1;</span><br><span class="line">        for(int i=3;i&lt;=n;++i)&#123;</span><br><span class="line">            for(int j=1;j&lt;i;++j)&#123;</span><br><span class="line">                dp[i]=Math.max(dp[i],dp[i-j]*j);</span><br><span class="line">                dp[i]=Math.max(dp[i],j*(i-j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011257295.png" alt="image-20240214165458490"></p>
<h2 id="10-7不同的二叉搜索树"><a href="#10-7不同的二叉搜索树" class="headerlink" title="10.7不同的二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-binary-search-trees/">10.7不同的二叉搜索树</a></h2><p>思路：n个节点的树可以分成三部分，根节点、左右子树，确定好根节点后左右子树节点数也就确定了，排列组合相乘即可得到该根节点下的所有情况</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int numTrees(int n) &#123;</span><br><span class="line">        if(n&lt;=2)&#123;</span><br><span class="line">            return n;</span><br><span class="line">        &#125;</span><br><span class="line">        int[]dp=new int[n+1];</span><br><span class="line">        dp[0]=1;</span><br><span class="line">        dp[1]=1;</span><br><span class="line">        dp[2]=2;</span><br><span class="line">        for(int i=3;i&lt;=n;++i)&#123;</span><br><span class="line">            for(int j=1;j&lt;=i;++j)&#123;</span><br><span class="line">                dp[i]+=(dp[i-j]*dp[j-1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011257301.png" alt="image-20240214181852889"></p>
<h2 id="10-8-0-1背包问题"><a href="#10-8-0-1背包问题" class="headerlink" title="10.8 0-1背包问题"></a><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1046">10.8 0-1背包问题</a></h2><p>思路：用二维数组记录前m件物品用n个位置的最大价值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line">        int m = sc.nextInt();</span><br><span class="line">        int n = sc.nextInt();</span><br><span class="line">        int[][] value = new int[m][2];</span><br><span class="line">        for(int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">            value[i][0] = sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">            value[i][1] = sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        int[][] dp = new int[n+1][m];</span><br><span class="line">        for(int i=value[0][0];i&lt;=n;++i)&#123;</span><br><span class="line">            dp[i][0]=value[0][1];</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=1;i&lt;m;++i)&#123;</span><br><span class="line">            for (int j = 1; j &lt;= n; ++j) &#123;</span><br><span class="line">                if(j&gt;=value[i][0]) &#123;</span><br><span class="line">                    dp[j][i] = Math.max(dp[j-value[i][0]][i-1]+value[i][1],dp[j][i-1]);</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    dp[j][i] = dp[j][i-1];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(dp[n][m-1]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011257647.png" alt="image-20240214212950914"></p>
<p>思路2：用一位数组记录使用i空间最大价值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line">        int m = sc.nextInt();</span><br><span class="line">        int n = sc.nextInt();</span><br><span class="line">        int[][] value = new int[m][2];</span><br><span class="line">        for(int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">            value[i][0] = sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">            value[i][1] = sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        int[]dp = new int[n+1];</span><br><span class="line">        for(int i = 0; i &lt; m; ++i) &#123;</span><br><span class="line">            for(int j=n;j&gt;=value[i][0];--j)&#123;</span><br><span class="line">                dp[j]=Math.max(dp[j],dp[j-value[i][0]]+value[i][1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(dp[n]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011257080.png" alt="image-20240214213835886"></p>
<h2 id="10-9分割等和子集"><a href="#10-9分割等和子集" class="headerlink" title="10.9分割等和子集"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-equal-subset-sum/">10.9分割等和子集</a></h2><p>思路：分成两个子集那么子集的和肯定是原数组和的一半，dp数组记录索引数值是否能通过子元素相加得到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean canPartition(int[] nums) &#123;</span><br><span class="line">        int sum=0;</span><br><span class="line">        for(int i=0;i&lt;nums.length;++i)&#123;</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        if(sum%2!=0)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        int len = sum/2;</span><br><span class="line">        int[]dp=new int[len+1];</span><br><span class="line">        dp[0]=1;</span><br><span class="line">        for(int i=0;i&lt;nums.length;++i)&#123;</span><br><span class="line">            for(int j=len;j&gt;=nums[i];--j)&#123;</span><br><span class="line">                if(dp[j-nums[i]]==1)&#123;</span><br><span class="line">                    dp[j]=1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(dp[len]==1)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011257720.png" alt="image-20240214220305425"></p>
<h2 id="10-10最后一块石头的重量Ⅱ"><a href="#10-10最后一块石头的重量Ⅱ" class="headerlink" title="10.10最后一块石头的重量Ⅱ"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/last-stone-weight-ii/">10.10最后一块石头的重量Ⅱ</a></h2><p>思路：跟上题差不多，dp数组表示索引重量是否可达，找到最接近重量总和一半的重量即可算出最后一块石头的重量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int lastStoneWeightII(int[] stones) &#123;</span><br><span class="line">        int sum=0;</span><br><span class="line">        for(int stone:stones)&#123;</span><br><span class="line">            sum+=stone;</span><br><span class="line">        &#125;</span><br><span class="line">        int avg = sum/2;</span><br><span class="line">        int[]dp=new int[avg+1];</span><br><span class="line">        dp[0]=1;</span><br><span class="line">        for(int stone:stones)&#123;</span><br><span class="line">            for(int i=avg;i&gt;=stone;--i)&#123;</span><br><span class="line">                if(dp[i-stone]==1)&#123;</span><br><span class="line">                    dp[i]=1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int i;</span><br><span class="line">        for(i=avg;i&gt;=0;--i)&#123;</span><br><span class="line">            if(dp[i]==1)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum-2*i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011257014.png" alt="image-20240215131256799"></p>
<h2 id="10-11目标和"><a href="#10-11目标和" class="headerlink" title="10.11目标和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/target-sum/">10.11目标和</a></h2><p>思路：如果按照上面的思路就要同时兼顾加和减两种情况，可能会出现一个数被多次加减或同时加和减的情况，所以这里先数学推导一下，设加了减号的数字总和为x，那么sum-x-x&#x3D;target，x&#x3D;（sum-target）&#x2F;2，这时候就只需要找到相加等于x的情况即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int findTargetSumWays(int[] nums, int target) &#123;</span><br><span class="line">        int sum=0;</span><br><span class="line">        for(int num:nums)&#123;</span><br><span class="line">            sum+=num;</span><br><span class="line">        &#125;</span><br><span class="line">        if(sum&lt;target||(sum-target)%2!=0)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int len=(sum-target)/2;</span><br><span class="line">        int[]dp=new int [len+1];</span><br><span class="line">        dp[0]=1;</span><br><span class="line">        for(int num:nums)&#123;</span><br><span class="line">            for(int i=len;i&gt;=num;--i)&#123;</span><br><span class="line">                dp[i]+=dp[i-num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[len];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011258103.png" alt="image-20240215142411632"></p>
<h2 id="10-12一和零"><a href="#10-12一和零" class="headerlink" title="10.12一和零"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ones-and-zeroes/">10.12一和零</a></h2><p>思路：还是动态规划01背包问题，dp二位数组记录最多m个0和n个1的最大字串数量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int findMaxForm(String[] strs, int m, int n) &#123;</span><br><span class="line">        int[][]dp=new int[m+1][n+1];</span><br><span class="line">        for(String str:strs)&#123;</span><br><span class="line">            int cnt0=0;</span><br><span class="line">            for(char ch:str.toCharArray())&#123;</span><br><span class="line">                if(ch==&#x27;0&#x27;)&#123;</span><br><span class="line">                    ++cnt0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            int cnt1=str.length()-cnt0;</span><br><span class="line">            for(int i=m;i&gt;=cnt0;--i)&#123;</span><br><span class="line">                for(int j=n;j&gt;=cnt1;--j)&#123;</span><br><span class="line">                    dp[i][j]=Math.max(dp[i][j],dp[i-cnt0][j-cnt1]+1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011258355.png" alt="image-20240215150112573"></p>
<h2 id="10-13完全背包"><a href="#10-13完全背包" class="headerlink" title="10.13完全背包"></a><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1052">10.13完全背包</a></h2><p>思路：完全背包跟01背包基本一样，只是01背包每件物品只能有一个，而完全背包可以有无数个，这时候就不需要为了保证一件物品而倒序遍历，直接正向遍历就可以了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line">        int n = scanner.nextInt();</span><br><span class="line">        int v  = scanner.nextInt();</span><br><span class="line">        int[] weights = new int[n];</span><br><span class="line">        int[] values = new int[n];</span><br><span class="line">        for(int i = 0; i &lt; n; ++i)&#123;</span><br><span class="line">            weights[i] = scanner.nextInt();</span><br><span class="line">            values[i] = scanner.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        int []dp=new int [v+1];</span><br><span class="line">        for(int i=0;i&lt;n;++i)&#123;</span><br><span class="line">            for(int j=weights[i];j&lt;=v;++j)&#123;</span><br><span class="line">                dp[j]=Math.max(dp[j],dp[j-weights[i]]+values[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(dp[v]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011258308.png" alt="image-20240215151846122"></p>
<h2 id="10-14零钱兑换Ⅱ"><a href="#10-14零钱兑换Ⅱ" class="headerlink" title="10.14零钱兑换Ⅱ"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change-ii/">10.14零钱兑换Ⅱ</a></h2><p>思路：完全背包问题，跟上题思路基本一致，dp数组记录了金额到索引的组合数，然后不用再倒序遍历保证只加一遍</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int change(int amount, int[] coins) &#123;</span><br><span class="line">        int[]dp=new int[amount+1];</span><br><span class="line">        dp[0]=1;</span><br><span class="line">        for(int coin:coins)&#123;</span><br><span class="line">            for(int i=coin;i&lt;=amount;++i)&#123;</span><br><span class="line">                dp[i]+=dp[i-coin];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011258692.png" alt="image-20240215152347457"></p>
<h2 id="10-15组合总和Ⅳ"><a href="#10-15组合总和Ⅳ" class="headerlink" title="10.15组合总和Ⅳ"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-iv/">10.15组合总和Ⅳ</a></h2><p>思路：还是完全背包问题，还是用dp数组记录达到索引的组合数，注意这里相同的数字不同顺序属于不同组合，{1,2,2}和{2,1,2}属于不同的组合，所以外层先遍历背包，内层遍历物品，这样就可以找到不同的组合顺序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int combinationSum4(int[] nums, int target) &#123;</span><br><span class="line">        int[]dp=new int [target+1];</span><br><span class="line">        dp[0]=1;</span><br><span class="line">        for(int i=0;i&lt;=target;++i)&#123;</span><br><span class="line">            for(int num:nums)&#123;</span><br><span class="line">                if(i&gt;=num)&#123;</span><br><span class="line">                    dp[i]+=dp[i-num];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011258502.png" alt="image-20240217193930490"></p>
<h2 id="10-16爬楼梯Ⅱ"><a href="#10-16爬楼梯Ⅱ" class="headerlink" title="10.16爬楼梯Ⅱ"></a><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1067">10.16爬楼梯Ⅱ</a></h2><p>思路：这里还是使用完全背包解决爬楼梯的问题，dp数组记录到达索引位置的方法数，然后遍历找到到达索引的方法组合数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int m,n;</span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line">        n = sc.nextInt();</span><br><span class="line">        m = sc.nextInt();</span><br><span class="line">        int[]dp = new int[n+1];</span><br><span class="line">        dp[0]=1;</span><br><span class="line">        for(int i=1;i&lt;=n;++i)&#123;</span><br><span class="line">            for(int j=Math.max(0,i-m);j&lt;i;++j)&#123;</span><br><span class="line">                dp[i]+=dp[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(dp[n]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011258270.png" alt="image-20240217200358706"></p>
<h2 id="10-17零钱兑换"><a href="#10-17零钱兑换" class="headerlink" title="10.17零钱兑换"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change/">10.17零钱兑换</a></h2><p>思路：还是使用背包来解题，硬币数量不限，所以是完全背包，dp数组记录装索引容量空间所需最少的硬币，因为要求最少，所以一开始初始化就不能是0了，只有对于初始容量是0的才能0个硬币装满，其他就没什么特殊的了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int coinChange(int[] coins, int amount) &#123;</span><br><span class="line">        int[]dp=new int[amount+1];</span><br><span class="line">        for(int i=1;i&lt;=amount;++i)&#123;</span><br><span class="line">            dp[i]=Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int coin:coins)&#123;</span><br><span class="line">            for(int i=coin;i&lt;=amount;++i)&#123;</span><br><span class="line">                if(dp[i-coin]!=Integer.MAX_VALUE)&#123;</span><br><span class="line">                    dp[i]=Math.min(dp[i-coin]+1,dp[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[amount] == Integer.MAX_VALUE ? -1 : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011258675.png" alt="image-20240217210048382"></p>
<h2 id="10-18完全平方数"><a href="#10-18完全平方数" class="headerlink" title="10.18完全平方数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/perfect-squares/">10.18完全平方数</a></h2><p>思路：有了上题的铺垫，这题也很容易就能想出来，还是完全背包的问题，dp数组的含义就是平方和等于索引的个数，因为求最小，所以初始化还是不能等于0</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int numSquares(int n) &#123;</span><br><span class="line">        int[]dp=new int[n+1];</span><br><span class="line">        for(int i=1;i&lt;=n;++i)&#123;</span><br><span class="line">            int min=Integer.MAX_VALUE;</span><br><span class="line">            for(int j=1;j*j&lt;=i;++j)&#123;</span><br><span class="line">                min=Math.min(1+dp[i-j*j],min);</span><br><span class="line">            &#125; </span><br><span class="line">            dp[i]=min;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011258839.png" alt="image-20240217222348091"></p>
<h2 id="10-19单词拆分"><a href="#10-19单词拆分" class="headerlink" title="10.19单词拆分"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-break/">10.19单词拆分</a></h2><p>思路：还是可以使用背包来解题，这里单词使用次数不限制，所以可以用完全背包来解，dp数组的含义就是s从0到索引位置的字串是否能通过链表的字符串拼接得到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123;</span><br><span class="line">        int[]dp=new int[s.length()+1];</span><br><span class="line">        dp[0]=1;</span><br><span class="line">        for(int i=1;i&lt;=s.length();++i)&#123;</span><br><span class="line">            for(String word:wordDict)&#123;</span><br><span class="line">                if(word.length()&gt;i||dp[i-word.length()]==0)&#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if(s.substring(i-word.length(),i).equals(word))&#123;</span><br><span class="line">                    dp[i]=1;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[s.length()]==1?true:false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011258409.png" alt="image-20240218123242953"></p>
<h2 id="10-20多重背包"><a href="#10-20多重背包" class="headerlink" title="10.20多重背包"></a><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1066">10.20多重背包</a></h2><p>思路：跟01背包问题差不多，不过区别是物品可以有多件，其实把多件相同的物品看成是多件不同的物品就可以得到答案，虽然将多件相同的物品看作不同，但是在处理上遍历dp数组的时候可以作空间和件数相乘处理优化时间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author yinjunbiao</span><br><span class="line"> * @version 1.0</span><br><span class="line"> * @date 2024/2/1</span><br><span class="line"> */</span><br><span class="line">class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line">        int c = scanner.nextInt();</span><br><span class="line">        int n = scanner.nextInt();</span><br><span class="line">        int[]w = new int[n];</span><br><span class="line">        int[]v = new int[n];</span><br><span class="line">        int[]k = new int[n];</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            w[i] = scanner.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            v[i] = scanner.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            k[i] = scanner.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        int[] dp = new int[c+1];</span><br><span class="line">        for(int i=0;i&lt;n;++i)&#123;</span><br><span class="line">            for(int j=c;j&gt;=w[i];--j)&#123;</span><br><span class="line">                for(int l=1;l&lt;=k[i]&amp;&amp;l*w[i]&lt;=j;++l)&#123;</span><br><span class="line">                    dp[j] = Math.max(dp[j],dp[j-l*w[i]]+l*v[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(dp[c]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011258867.png" alt="image-20240219153925086"></p>
<h2 id="10-21打家劫舍"><a href="#10-21打家劫舍" class="headerlink" title="10.21打家劫舍"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber/">10.21打家劫舍</a></h2><p>思路：dp数组记录偷到索引位置最高金额，因为不能偷相邻的两间房屋，所以分为上一家偷不偷的情况，到状态方程为dp[i]&#x3D;Math.max(dp[i-2]+nums[i],dp[i-1]);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int rob(int[] nums) &#123;</span><br><span class="line">        if(nums.length==1)&#123;</span><br><span class="line">            return nums[0];</span><br><span class="line">        &#125;</span><br><span class="line">        int[]dp=new int[nums.length];</span><br><span class="line">        dp[0]=nums[0];</span><br><span class="line">        dp[1]=Math.max(nums[0],nums[1]);</span><br><span class="line">        for(int i=2;i&lt;nums.length;++i)&#123;</span><br><span class="line">            dp[i]=Math.max(dp[i-2]+nums[i],dp[i-1]);</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[nums.length-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011258228.png" alt="image-20240219160913789"></p>
<h2 id="10-22打家劫舍Ⅱ"><a href="#10-22打家劫舍Ⅱ" class="headerlink" title="10.22打家劫舍Ⅱ"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber-ii/">10.22打家劫舍Ⅱ</a></h2><p>思路：这题跟上题基本一直，唯一区别就是房屋围成了圈，如果偷了头就不能偷尾，偷了尾就不能偷头，所以这里我们分两种情况计算偷第一间和不偷第一间的情况</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int rob(int[] nums) &#123;</span><br><span class="line">        if(nums.length==1)&#123;</span><br><span class="line">            return nums[0];</span><br><span class="line">        &#125;</span><br><span class="line">        int[][]dp=new int[nums.length][2];</span><br><span class="line">        dp[0][0]=nums[0];</span><br><span class="line">        dp[1][0]=nums[0];</span><br><span class="line">        dp[0][1]=0;</span><br><span class="line">        dp[1][1]=nums[1];</span><br><span class="line">        for(int i=2;i&lt;nums.length;++i)&#123;</span><br><span class="line">            dp[i][0]=Math.max(dp[i-2][0]+nums[i],dp[i-1][0]);</span><br><span class="line">            dp[i][1]=Math.max(dp[i-2][1]+nums[i],dp[i-1][1]);</span><br><span class="line">        &#125;</span><br><span class="line">        return Math.max(dp[nums.length-2][0],dp[nums.length-1][1]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011258953.png" alt="image-20240219165306436"></p>
<h2 id="10-23打家劫舍Ⅲ"><a href="#10-23打家劫舍Ⅲ" class="headerlink" title="10.23打家劫舍Ⅲ"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber-iii/">10.23打家劫舍Ⅲ</a></h2><p>思路：跟上题相同的思路，但是从数组变成二叉树，相邻变成了父子节点，所以一个节点的最大价值等于该节点价值+孙子节点最大价值的和 跟 左右子节点最大价值和 的较大值，为了找到最大价值所以要从叶子节点开始向父节点走</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int rob(TreeNode root) &#123;</span><br><span class="line">        robAction(root);</span><br><span class="line">        return root.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void robAction(TreeNode node)&#123;</span><br><span class="line">        if(node==null)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        robAction(node.left);</span><br><span class="line">        robAction(node.right);</span><br><span class="line">        int son=0;</span><br><span class="line">        int grandSon = node.val;</span><br><span class="line">        if(node.left!=null)&#123;</span><br><span class="line">            son+=node.left.val;</span><br><span class="line">            if(node.left.left!=null)&#123;</span><br><span class="line">                grandSon+=node.left.left.val;</span><br><span class="line">            &#125;</span><br><span class="line">            if(node.left.right!=null)&#123;</span><br><span class="line">                grandSon+=node.left.right.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(node.right!=null)&#123;</span><br><span class="line">            son+=node.right.val;</span><br><span class="line">            if(node.right.left!=null)&#123;</span><br><span class="line">                grandSon+=node.right.left.val;</span><br><span class="line">            &#125;</span><br><span class="line">            if(node.right.right!=null)&#123;</span><br><span class="line">                grandSon+=node.right.right.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        node.val=Math.max(son,grandSon);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011258660.png" alt="image-20240219211747385"></p>
<h2 id="10-24买卖股票的最佳时机"><a href="#10-24买卖股票的最佳时机" class="headerlink" title="10.24买卖股票的最佳时机"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">10.24买卖股票的最佳时机</a></h2><p>思路：贪心，一次遍历数组记录索引前位置最小值，要在索引点卖出股票收益最大必在最小值处买入，然后找到卖出的最大值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxProfit(int[] prices) &#123;</span><br><span class="line">        int min=prices[0];</span><br><span class="line">        int ans=0;</span><br><span class="line">        for(int i=1;i&lt;prices.length;++i)&#123;</span><br><span class="line">            ans=Math.max(ans,prices[i]-min);</span><br><span class="line">            min=Math.min(min,prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011258861.png" alt="image-20240219215957106"></p>
<p>思路2：动态规划，二位数组一行表示当前持有股票的最大收益，第二行表示当前不持有股票的最大收益</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxProfit(int[] prices) &#123;</span><br><span class="line">        int[][]dp=new int[prices.length][2];</span><br><span class="line">        dp[0][0]=-prices[0];</span><br><span class="line">        for(int i=1;i&lt;prices.length;++i)&#123;</span><br><span class="line">            dp[i][0]=Math.max(dp[i-1][0],-prices[i]);</span><br><span class="line">            dp[i][1]=Math.max(prices[i]+dp[i-1][0],dp[i-1][1]);</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[prices.length-1][1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011258867.png" alt="image-20240219220638926"></p>
<h2 id="10-25买卖股票的最佳时机Ⅱ"><a href="#10-25买卖股票的最佳时机Ⅱ" class="headerlink" title="10.25买卖股票的最佳时机Ⅱ"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">10.25买卖股票的最佳时机Ⅱ</a></h2><p>思路：在贪心算法 9.4已经有过贪心方法解题，这里再说一下动态规划。还是跟上题一样，一行表示当前持有股票的最大收益，一行表示当前不持有股票的最大收益</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxProfit(int[] prices) &#123;</span><br><span class="line">        int[][] dp = new int[2][prices.length + 1];</span><br><span class="line">        dp[0][0] = -prices[0];</span><br><span class="line">        for (int i = 1; i &lt; prices.length; ++i) &#123;</span><br><span class="line">            dp[0][i] = Math.max(dp[1][i - 1] - prices[i], dp[0][i - 1]);</span><br><span class="line">            dp[1][i] = Math.max(dp[0][i - 1] + prices[i], dp[1][i - 1]);</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[1][prices.length - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011258122.png" alt="image-20240219221126958"></p>
<h2 id="10-26买卖股票的最佳时机Ⅲ"><a href="#10-26买卖股票的最佳时机Ⅲ" class="headerlink" title="10.26买卖股票的最佳时机Ⅲ"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">10.26买卖股票的最佳时机Ⅲ</a></h2><p>思路：跟上题一样，动态规划模拟当前持有或不持有股票，但是这里可以买卖两次，所以用4行模拟第一次持有，第一次卖，第二次持有，第二次卖即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxProfit(int[] prices) &#123;</span><br><span class="line">        int[][]dp=new int[prices.length][4];</span><br><span class="line">        dp[0][0]=-prices[0];</span><br><span class="line">        dp[0][2]=-prices[0];</span><br><span class="line">        for(int i=1;i&lt;prices.length;++i)&#123;</span><br><span class="line">            dp[i][0]=Math.max(dp[i-1][0],-prices[i]);</span><br><span class="line">            dp[i][1]=Math.max(dp[i-1][1],prices[i]+dp[i-1][0]);</span><br><span class="line">            dp[i][2]=Math.max(dp[i-1][2],dp[i][1]-prices[i]);</span><br><span class="line">            dp[i][3]=Math.max(dp[i-1][3],prices[i]+dp[i][2]);</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[prices.length-1][3];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011258897.png" alt="image-20240219222417380"></p>
<h2 id="10-27买卖股票的最佳时机Ⅳ"><a href="#10-27买卖股票的最佳时机Ⅳ" class="headerlink" title="10.27买卖股票的最佳时机Ⅳ"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">10.27买卖股票的最佳时机Ⅳ</a></h2><p>思路：跟上题一样，双数行dp数组记录当前不持有股票的最大值，其余行记录当前持有股票的最大值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxProfit(int k, int[] prices) &#123;</span><br><span class="line">        int[][]dp=new int[prices.length][2*k];</span><br><span class="line">        for(int i=0;i&lt;k;++i)&#123;</span><br><span class="line">            dp[0][i*2]=-prices[0];</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=1;i&lt;prices.length;++i)&#123;</span><br><span class="line">            for(int j=0;j&lt;k;++j)&#123;</span><br><span class="line">                dp[i][j*2]=Math.max(dp[i-1][j*2],dp[i][Math.max(0,j*2-1)]-prices[i]);</span><br><span class="line">                dp[i][j*2+1]=Math.max(dp[i-1][j*2+1],dp[i][j*2]+prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[prices.length-1][2*k-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011259720.png" alt="image-20240220120537017"></p>
<h2 id="10-28买卖股票的最佳时机含冷冻期"><a href="#10-28买卖股票的最佳时机含冷冻期" class="headerlink" title="10.28买卖股票的最佳时机含冷冻期"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">10.28买卖股票的最佳时机含冷冻期</a></h2><p>思路：跟不含冷冻期一样的思路，dp数组一行记录持有股票最大价值，一行记录不持有股票最大价值，但是这里有冷冻期，在冷冻期不能购买股票，所以可以将不持有股票分为冷冻期和非冷冻期，记录三种情况的最大价值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxProfit(int[] prices) &#123;</span><br><span class="line">        if(prices.length==1)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int [][]dp=new int[prices.length][3];</span><br><span class="line">        //0:持有 1：冷冻期 2：不持有且可买入</span><br><span class="line">        dp[0][0]=-prices[0];</span><br><span class="line">        for(int i=1;i&lt;prices.length;++i)&#123;</span><br><span class="line">            dp[i][0]=Math.max(dp[i-1][0],dp[i-1][2]-prices[i]);</span><br><span class="line">            dp[i][1]=prices[i]+dp[i][0];</span><br><span class="line">            dp[i][2]=Math.max(dp[i-1][2],dp[i-1][1]);</span><br><span class="line">        &#125;</span><br><span class="line">        return Math.max(dp[prices.length-1][2],dp[prices.length-1][1]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011259255.png" alt="image-20240220194406925"></p>
<h2 id="10-29买卖股票的最佳时机含手续费"><a href="#10-29买卖股票的最佳时机含手续费" class="headerlink" title="10.29买卖股票的最佳时机含手续费"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">10.29买卖股票的最佳时机含手续费</a></h2><p>思路：跟不含手续费其实一样，只要在dp数组推导的时候要在卖出股票时扣去手续费即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxProfit(int[] prices, int fee) &#123;</span><br><span class="line">        </span><br><span class="line">        int[][]dp=new int[prices.length][2];</span><br><span class="line">        dp[0][0]=-prices[0];</span><br><span class="line">        for(int i=1;i&lt;prices.length;++i)&#123;</span><br><span class="line">            dp[i][0]=Math.max(dp[i-1][0],dp[i-1][1]-prices[i]);</span><br><span class="line">            dp[i][1]=Math.max(dp[i-1][1],dp[i][0]+prices[i]-fee);</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[prices.length-1][1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011259261.png" alt="image-20240220200348238"></p>
<h2 id="10-30最长递增子序列"><a href="#10-30最长递增子序列" class="headerlink" title="10.30最长递增子序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-increasing-subsequence/">10.30最长递增子序列</a></h2><p>思路：这题可以使用动态规划做出，首先确定dp数组的含义,dp数组表示索引前最大自增子序列长度，这时候状态方程也可以确定了，dp[i]&#x3D;Math.max(max,dp[j]+1);明确这点之后就可以做题了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int lengthOfLIS(int[] nums) &#123;</span><br><span class="line">        int[]dp=new int[nums.length];</span><br><span class="line">        dp[0]=1;</span><br><span class="line">        int max=1;</span><br><span class="line">        int res=1;</span><br><span class="line">        for(int i=1;i&lt;nums.length;++i)&#123;</span><br><span class="line">            for(int j=0;j&lt;i;++j)&#123;</span><br><span class="line">                if(nums[j]&lt;nums[i])&#123;</span><br><span class="line">                    max=Math.max(max,dp[j]+1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i]=max;</span><br><span class="line">            res=Math.max(res,dp[i]);</span><br><span class="line">            max=1;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011259698.png" alt="image-20240224145030938"></p>
<h2 id="10-31最长连续递增序列"><a href="#10-31最长连续递增序列" class="headerlink" title="10.31最长连续递增序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-continuous-increasing-subsequence/">10.31最长连续递增序列</a></h2><p>思路：贪心，记录当前当前索引结尾的最大连续递增序列长度，只要当前索引值比上一位置大就+1，否则清零，记录最大值即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int findLengthOfLCIS(int[] nums) &#123;</span><br><span class="line">        int res=1;</span><br><span class="line">        int cur=1;</span><br><span class="line">        for(int i=1;i&lt;nums.length;++i)&#123;</span><br><span class="line">            if(nums[i]&gt;nums[i-1])&#123;</span><br><span class="line">                res=Math.max(++cur,res);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                cur=1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011259975.png" alt="image-20240224145730577"></p>
<h2 id="10-32最长重复子数组"><a href="#10-32最长重复子数组" class="headerlink" title="10.32最长重复子数组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/">10.32最长重复子数组</a></h2><p>思路：这题如果用暴力解法只需要两层循环确定两个数组的起始位置，然后找到最长公共部分即可，但是这题也很适合用动态规划解决，首先确定dp数组的含义</p>
<p>dp[i][j]表示以num1[i]和num2[j]结尾的最大子数组长度是多少，这样就可以确定递推公式了。当num1[i]等于num2[j]时dp[i][j]&#x3D;dp[i-1][j-1]+1，这里还要特殊初始化一下i和j等于0的特殊情况就可以了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int findLength(int[] nums1, int[] nums2) &#123;</span><br><span class="line">        int[][]dp=new int[nums1.length][nums2.length];</span><br><span class="line">        int res=0;</span><br><span class="line">        for(int i=0;i&lt;nums1.length;++i)&#123;</span><br><span class="line">            if(nums1[i]==nums2[0])&#123;</span><br><span class="line">                dp[i][0]=1;</span><br><span class="line">                res=1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;nums2.length;++i)&#123;</span><br><span class="line">            if(nums2[i]==nums1[0])&#123;</span><br><span class="line">                dp[0][i]=1;</span><br><span class="line">                res=1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=1;i&lt;nums1.length;++i)&#123;</span><br><span class="line">            for(int j=1;j&lt;nums2.length;++j)&#123;</span><br><span class="line">                if(nums1[i]==nums2[j])&#123;</span><br><span class="line">                    dp[i][j]=dp[i-1][j-1]+1;</span><br><span class="line">                &#125;</span><br><span class="line">                res=Math.max(res,dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011259054.png" alt="image-20240224152216108"></p>
<h2 id="10-33最长公共子序列"><a href="#10-33最长公共子序列" class="headerlink" title="10.33最长公共子序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-common-subsequence/">10.33最长公共子序列</a></h2><p>思路：还是用动态规划去做，首先确定dp数组的含义，题目中的子序列不需要连续，所以dp[i][j]的含义就是text1从0到i和text2从0到j最长公共子序列，这时候就确定了递推公式，当字符相等时dp[i][j]&#x3D;dp[i-1][j-1]+1;不相等时dp[i][j]&#x3D;Math.max(dp[i-1][j],dp[i][j-1]);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int longestCommonSubsequence(String text1, String text2) &#123;</span><br><span class="line">        int[][]dp=new int [text1.length()+1][text2.length()+1];</span><br><span class="line">        int res=0;</span><br><span class="line">        for(int i=1;i&lt;=text1.length();++i)&#123;</span><br><span class="line">            for(int j=1;j&lt;=text2.length();++j)&#123;</span><br><span class="line">                if(text1.charAt(i-1)==text2.charAt(j-1))&#123;</span><br><span class="line">                    dp[i][j]=dp[i-1][j-1]+1;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    dp[i][j]=Math.max(dp[i-1][j],dp[i][j-1]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[text1.length()][text2.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011259859.png" alt="image-20240225211757629"></p>
<h2 id="10-34不相交的线"><a href="#10-34不相交的线" class="headerlink" title="10.34不相交的线"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/uncrossed-lines/">10.34不相交的线</a></h2><p>思路：还是动态规划，首先确定dp数组的含义，这里用二维dp数组表示nums1从0到i的子数组和nums2从0到j的子数组最多的不相交的线的数量，这时候的递推公式就能轻松推算出来了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxUncrossedLines(int[] nums1, int[] nums2) &#123;</span><br><span class="line">        int[][]dp=new int[nums1.length+1][nums2.length+1];</span><br><span class="line">        for(int i=1;i&lt;=nums1.length;++i)&#123;</span><br><span class="line">            for(int j=1;j&lt;=nums2.length;++j)&#123;</span><br><span class="line">                if(nums1[i-1]==nums2[j-1])&#123;</span><br><span class="line">                    dp[i][j]=dp[i-1][j-1]+1;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    dp[i][j]=Math.max(dp[i-1][j],dp[i][j-1]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[nums1.length][nums2.length];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011259314.png" alt="image-20240227225651926"></p>
<h2 id="10-35最大子序和"><a href="#10-35最大子序和" class="headerlink" title="10.35最大子序和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray/">10.35最大子序和</a></h2><p>思路：题目中要找到连续的子数组，并使子数组最大，首先想到的是滑动窗口，连续的数组很容易就想到了要用滑动窗口去维护，只要窗口内数字的和大于0就一直往后延申，找到最大和</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxSubArray(int[] nums) &#123;</span><br><span class="line">        int fast=1;</span><br><span class="line">        int slow=0;</span><br><span class="line">        int ans=nums[0];</span><br><span class="line">        int cur=nums[0];</span><br><span class="line">        while(fast&lt;nums.length)&#123;</span><br><span class="line">            if(cur&lt;0)&#123;</span><br><span class="line">                slow=fast;</span><br><span class="line">                cur=0;</span><br><span class="line">            &#125;</span><br><span class="line">            cur+=nums[fast++];</span><br><span class="line">            ans=Math.max(ans,cur);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011259151.png" alt="image-20240227232826671"></p>
<p>思路2：贪心算法，其实这题贪心算法跟上题过程差不多，遍历数组，维护索引前一段子数组的和，如果子数组的和为负数则抛弃前面的子数组从当前索引开始算</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxSubArray(int[] nums) &#123;</span><br><span class="line">        int ans=nums[0];</span><br><span class="line">        int pre=nums[0];</span><br><span class="line">        for(int i=1;i&lt;nums.length;++i)&#123;</span><br><span class="line">            pre=Math.max(pre,0)+nums[i];</span><br><span class="line">            ans=Math.max(pre,ans);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011259869.png" alt="image-20240227233345738"></p>
<p>思路3：动态规划，这题是动态规划的典型题目，首先确定dp数组的含义，dp数组代表从0到索引位置的子数组最大的连续子数组和，然后我们就可以确定递推公式了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxSubArray(int[] nums) &#123;</span><br><span class="line">        int[]dp=new int[nums.length];</span><br><span class="line">        dp[0]=nums[0];</span><br><span class="line">        int res=nums[0];</span><br><span class="line">        for(int i=1;i&lt;nums.length;++i)&#123;</span><br><span class="line">            dp[i]=Math.max(dp[i-1],0)+nums[i];</span><br><span class="line">            res=Math.max(res,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011259437.png" alt="image-20240227233851490"></p>
<h2 id="10-36判断子序列"><a href="#10-36判断子序列" class="headerlink" title="10.36判断子序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/is-subsequence/">10.36判断子序列</a></h2><p>思路：两个指针分别遍历两个字符串，当t中所指字符跟s中字符相等时，s的指针后移，当s的指针遍历完s，代表t中存在字串s</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isSubsequence(String s, String t) &#123;</span><br><span class="line">        if(s.length()==0)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        int index=0;</span><br><span class="line">        for(int i=0;i&lt;t.length();++i)&#123;</span><br><span class="line">            if(s.charAt(index)==t.charAt(i))&#123;</span><br><span class="line">                if(++index==s.length())&#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011259431.png" alt="image-20240228103334877"></p>
<h2 id="10-37不同的子序列"><a href="#10-37不同的子序列" class="headerlink" title="10.37不同的子序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/distinct-subsequences/">10.37不同的子序列</a></h2><p>思路：这题还是可以使用动态规划，首先确定dp数组的含义，二维数组dp[i][j]表示以i-1结尾的s子序列中出现以j-1结尾的t序列的个数，也就可以确定了递推公式，当s的i等于t的j，dp[i][j]等于不包含s的i加上包含s的i的t的j-1的子序列之和，即dp[i-1][j-1]+dp[i-1][j]，如果不相等，那么dp[i][j]等于不包含s的i的t的j-1子序列之和，即dp[i-1][j]，确定之后这道题就简单了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int numDistinct(String s, String t) &#123;</span><br><span class="line">        int[][]dp=new int[s.length()+1][t.length()+1];</span><br><span class="line">        for(int i=0;i&lt;=s.length();++i)&#123;</span><br><span class="line">            dp[i][0]=1;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=1;i&lt;=s.length();++i)&#123;</span><br><span class="line">            for(int j=1;j&lt;=t.length();++j)&#123;</span><br><span class="line">                if(s.charAt(i-1)==t.charAt(j-1))&#123;</span><br><span class="line">                    dp[i][j]=dp[i-1][j]+dp[i-1][j-1];</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    dp[i][j]=dp[i-1][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[s.length()][t.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011259840.png" alt="image-20240312101656594"></p>
<h2 id="10-38两个字符串的删除操作"><a href="#10-38两个字符串的删除操作" class="headerlink" title="10.38两个字符串的删除操作"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/delete-operation-for-two-strings/">10.38两个字符串的删除操作</a></h2><p>思路：还是动态规划，首先确定dp数组的含义，dp[i][j]表示以i结尾的word1和以j结尾的word2需要相同的最小步数。接下来就可以确定dp数组的递推公式，当word1的i等于word2的j，那么删除的最小步数就等于word的i-1和word2的j-1所需删除的最小步数，如果不相等，就等于word1的i和word2的j-1 与 word1的i-1和word2的j 所需最小步数的较小值加1，然后还需初始化边界值，保证步数正确</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int minDistance(String word1, String word2) &#123;</span><br><span class="line">        int[][]dp=new int[word1.length()+1][word2.length()+1];</span><br><span class="line">        for(int i=1;i&lt;=word1.length();++i)&#123;</span><br><span class="line">            dp[i][0]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j=1;j&lt;=word2.length();++j)&#123;</span><br><span class="line">            dp[0][j]=j;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=1;i&lt;=word1.length();++i)&#123;</span><br><span class="line">            for(int j=1;j&lt;=word2.length();++j)&#123;</span><br><span class="line">                if(word1.charAt(i-1) == word2.charAt(j-1))&#123;</span><br><span class="line">                    dp[i][j]=dp[i-1][j-1];</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    dp[i][j]=Math.min(dp[i-1][j],dp[i][j-1])+1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[word1.length()][word2.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011259137.png" alt="image-20240313161722986"></p>
<h2 id="10-39编辑距离"><a href="#10-39编辑距离" class="headerlink" title="10.39编辑距离"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/edit-distance/">10.39编辑距离</a></h2><p>思路：这题跟上题基本一样，对一个字符串增加和删除等于对两个字符串删除，唯一不同的地方就是本题多了替换，可以替换的话在word1的i和word2的j不同时dp[i][j]可以等于dp[i-1][j-1]+1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int minDistance(String word1, String word2) &#123;</span><br><span class="line">        int[][]dp=new int [word1.length()+1][word2.length()+1];</span><br><span class="line">        for(int i=1;i&lt;=word1.length();++i)&#123;</span><br><span class="line">            dp[i][0]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j=1;j&lt;=word2.length();++j)&#123;</span><br><span class="line">            dp[0][j]=j;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=1;i&lt;=word1.length();++i)&#123;</span><br><span class="line">            for(int j=1;j&lt;=word2.length();++j)&#123;</span><br><span class="line">                if(word1.charAt(i-1)==word2.charAt(j-1))&#123;</span><br><span class="line">                    dp[i][j]=dp[i-1][j-1];</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    dp[i][j]=Math.min(Math.min(dp[i-1][j],dp[i][j-1]),dp[i-1][j-1])+1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[word1.length()][word2.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011259251.png" alt="image-20240313204523927"></p>
<h2 id="10-40回文字串"><a href="#10-40回文字串" class="headerlink" title="10.40回文字串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindromic-substrings/">10.40回文字串</a></h2><p>思路：这题还是可以用动态规划做出，首先确定dp数组的含义，一般来说题目要求什么dp数组的含义也就是什么，但是在这题，如果要dp数组表示以i结尾的回文字串，并不好推出下一个阶段的回文字串，如果要根据上一个阶段推出下一个阶段，就需要用到二维数组，dp[i][j]代表i到j的字串是否是回文字符串。</p>
<p>确定了dp数组的含义，接下来就需要确定递推公式，当要判断i到j的字符串是否为回文字符串，可以由i+1和j-1是否为回文字符串判断，如果是回文字符串，且i和j位置字符相等，那么就可以确定是回文字符串，如果不相等就不是回文，如果j-1小于等于1，且i和j位置字符相等，那么也是回文字符，可以把逻辑整理一下，分成i和j位置字符相不相同的情况处理</p>
<p>接下来还有一个地方需要注意的就是遍历的顺序，因为dp[i][j]需要根据dp[i+1][j-1]判断，后者在前者的左下角，所以需要从下到上，从左到右开始遍历</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int countSubstrings(String s) &#123;</span><br><span class="line">        int[][]dp=new int[s.length()][s.length()];</span><br><span class="line">        int cnt=0;</span><br><span class="line">        dp[0][0]=1;</span><br><span class="line">        for(int i=s.length()-1;i&gt;=0;--i)&#123;</span><br><span class="line">            for(int j=i;j&lt;s.length();++j)&#123;</span><br><span class="line">                if(s.charAt(i)==s.charAt(j))&#123;</span><br><span class="line">                    if(j-i&lt;=1||dp[i+1][j-1]==1)&#123;</span><br><span class="line">                        dp[i][j]=1;</span><br><span class="line">                        ++cnt;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011300217.png" alt="image-20240314100456266"></p>
<h2 id="10-41最长回文子序列"><a href="#10-41最长回文子序列" class="headerlink" title="10.41最长回文子序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-palindromic-subsequence/">10.41最长回文子序列</a></h2><p>思路：跟上题思路差不多，但是二维dp数组表示从i到j字串中最大的字串长度，遍历的顺序也跟上题差不多，因为要根据dp[i+1][j-1]的状态推导出dp[i][j]的状态，所以还是要从下到上，从左到右</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int longestPalindromeSubseq(String s) &#123;</span><br><span class="line">        int[][]dp=new int [s.length()+1][s.length()+1];</span><br><span class="line">        for(int i=s.length()-1;i&gt;=0;--i)&#123;</span><br><span class="line">            dp[i][i]=1;</span><br><span class="line">            for(int j=i+1;j&lt;s.length();++j)&#123;</span><br><span class="line">                if(s.charAt(i)==s.charAt(j))&#123;</span><br><span class="line">                    dp[i][j]=dp[i+1][j-1]+2;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    dp[i][j]=Math.max(dp[i+1][j],dp[i][j-1]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[0][s.length()-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011300189.png" alt="image-20240314113045737"></p>
<h1 id="11单调栈"><a href="#11单调栈" class="headerlink" title="11单调栈"></a>11单调栈</h1><h2 id="11-1每日温度"><a href="#11-1每日温度" class="headerlink" title="11.1每日温度"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/daily-temperatures/">11.1每日温度</a></h2><p>思路：最简单的方法还是双重循环暴力，对于每个位置都往后遍历找到第一个比他大的元素</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] dailyTemperatures(int[] temperatures) &#123;</span><br><span class="line">        int[] answer = new int[temperatures.length];</span><br><span class="line">        for(int i=0;i&lt;temperatures.length;++i)&#123;</span><br><span class="line">            int j=i+1;</span><br><span class="line">            while(j&lt;temperatures.length&amp;&amp;temperatures[j]&lt;=temperatures[i])&#123;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            if(j!=temperatures.length)&#123;</span><br><span class="line">                answer[i]=j-i;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                answer[i]=0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011300408.png" alt="image-20240422150918850"></p>
<p>优化：上面暴力二重循环时间复杂度是O（n^2），有什么办法可以将时间复杂度压缩到O（n）呢，这里可以使用单调栈来解决这个问题，首先还是遍历数组，然后用一个栈把索引位置i前数字大于等于当前位置数字的索引记录下来，假设temperatures[i]&gt;temperatures[j]，i就是j右边第一个比j大的数字的索引，如果temperatures[i]&lt;&#x3D;temperatures[j]，则将i入栈</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] dailyTemperatures(int[] temperatures) &#123;</span><br><span class="line">        int[] answer = new int[temperatures.length];</span><br><span class="line">        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        stack.push(0);</span><br><span class="line">        for(int i=1;i&lt;temperatures.length;++i)&#123;</span><br><span class="line">            while(stack.size()&gt;0&amp;&amp;temperatures[i]&gt;temperatures[stack.peek()])&#123;</span><br><span class="line">                answer[stack.peek()]=i-stack.peek();</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://sunsetsouol.oss-cn-guangzhou.aliyuncs.com/pic/202405011300927.png" alt="image-20240422153159768"></p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="有多少小于当前数字的数字"><a href="#有多少小于当前数字的数字" class="headerlink" title="有多少小于当前数字的数字"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/how-many-numbers-are-smaller-than-the-current-number/">有多少小于当前数字的数字</a></h3><p>思路：最容易想到的还是双重暴力循环</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] smallerNumbersThanCurrent(int[] nums) &#123;</span><br><span class="line">        int[] res = new int[nums.length];</span><br><span class="line">        for(int i =0 ;i &lt; nums.length;++i)&#123;</span><br><span class="line">            int cnt = 0;</span><br><span class="line">            for(int j=0;j&lt;nums.length;++j)&#123;</span><br><span class="line">                if(nums[i] &gt; nums[j])&#123;</span><br><span class="line">                    ++cnt;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res[i]=cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这里还是有点慢，怎么优化呢，这里要统计比数字小的有多少个数，很容易想到排序数组，然后用前缀和统计有多少个数，但是如果要用前缀和的化，怎么映射数字和数量是需要考虑的，最容易想到的就是用map映射，但是map进行前缀和相加的时候比较麻烦，观察到题目给出数字最大只有100，所以可以用长度为101的数组代替map</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] smallerNumbersThanCurrent(int[] nums) &#123;</span><br><span class="line">        int[] cnt = new int[101];</span><br><span class="line">        for(int i=0;i&lt;nums.length;++i)&#123;</span><br><span class="line">            ++cnt[nums[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=1;i&lt;cnt.length;++i)&#123;</span><br><span class="line">            cnt[i]+=cnt[i-1];</span><br><span class="line">        &#125;</span><br><span class="line">        int[] res = new int[nums.length];</span><br><span class="line">        for(int i=0;i&lt;res.length;++i)&#123;</span><br><span class="line">            res[i]=nums[i] &gt;0 ?cnt[nums[i]-1] : 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="有效的山脉数组"><a href="#有效的山脉数组" class="headerlink" title="有效的山脉数组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-mountain-array/">有效的山脉数组</a></h3><p>直接两次循环模拟</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean validMountainArray(int[] arr) &#123;</span><br><span class="line">        if(arr.length&lt;3)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        int i=1;</span><br><span class="line">        while( i&lt;arr.length &amp;&amp; arr[i]&gt;arr[i-1])&#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        if(i&gt;arr.length-1 || i == 1)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        while( i&lt;arr.length &amp;&amp; arr[i] &lt; arr[i-1])&#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        if(i==arr.length)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>双指针法：一个从前往后，一个从后往前</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean validMountainArray(int[] arr) &#123;</span><br><span class="line">        if(arr.length&lt;3)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        int left = 1;</span><br><span class="line">        int right = arr.length-2;</span><br><span class="line">        while(left &lt; arr.length &amp;&amp; arr[left] &gt; arr[left-1])&#123;</span><br><span class="line">            ++left;</span><br><span class="line">        &#125;</span><br><span class="line">        while(right&gt;=0 &amp;&amp; arr[right] &gt; arr[right+1]) &#123;</span><br><span class="line">            --right;</span><br><span class="line">        &#125;</span><br><span class="line">        if (left == 1 || right == arr.length -2 || !(left&gt;right))&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="独一无二的出现次数"><a href="#独一无二的出现次数" class="headerlink" title="独一无二的出现次数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-number-of-occurrences/">独一无二的出现次数</a></h3><p>思路：用map记录每个数字出现的次数，然后把次数用set去重，比较map的key跟去重的个数是否相同，如果相同则每个数字的出现次数都是独一无二的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean uniqueOccurrences(int[] arr) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        for(int i=0;i&lt;arr.length;++i)&#123;</span><br><span class="line">            map.put(arr[i], map.getOrDefault(arr[i],0)+1);</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Integer&gt; set = new HashSet&lt;&gt;(map.values());</span><br><span class="line">        return set.size()==map.keySet().size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="移动零"><a href="#移动零" class="headerlink" title="移动零"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/move-zeroes/">移动零</a></h3><p>思路：双指针，将0往后移</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void moveZeroes(int[] nums) &#123;</span><br><span class="line">        if(nums.length&lt;2)&#123;</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line">        int left=0;</span><br><span class="line">        int right=0;</span><br><span class="line">        while(right&lt;nums.length)&#123;</span><br><span class="line">            while(right&lt;nums.length&amp;&amp;nums[right]==0)&#123;</span><br><span class="line">                ++right;</span><br><span class="line">            &#125;</span><br><span class="line">            if(right&lt;nums.length)&#123;</span><br><span class="line">                int t=nums[left];</span><br><span class="line">                nums[left++]=nums[right];</span><br><span class="line">                nums[right++]=t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="轮转数组"><a href="#轮转数组" class="headerlink" title="轮转数组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/rotate-array/">轮转数组</a></h3><p>思路：用一个新数组存轮转后的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void rotate(int[] nums, int k) &#123;</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = k;</span><br><span class="line">        int[] array = new int[nums.length];</span><br><span class="line">        for(int i=0;i&lt;nums.length;++i)&#123;</span><br><span class="line">            array[(i+k)%nums.length]=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;nums.length;++i)&#123;</span><br><span class="line">            nums[i]=array[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="寻找数组的中心下标"><a href="#寻找数组的中心下标" class="headerlink" title="寻找数组的中心下标"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-pivot-index/">寻找数组的中心下标</a></h3><p>思路：一次遍历先取总和，第二次遍历分别知道左右两边的和是多少</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int pivotIndex(int[] nums) &#123;</span><br><span class="line">        int right = 0;</span><br><span class="line">        for(int i=0;i&lt;nums.length;++i)&#123;</span><br><span class="line">            right+=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        int left=0;</span><br><span class="line">        for(int i=0;i&lt;nums.length;++i)&#123;</span><br><span class="line">            right-=nums[i];</span><br><span class="line">            if(left==right)&#123;</span><br><span class="line">                return i;</span><br><span class="line">            &#125;</span><br><span class="line">            left+=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="按奇偶排序数组-II"><a href="#按奇偶排序数组-II" class="headerlink" title=" 按奇偶排序数组 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-array-by-parity-ii/"> 按奇偶排序数组 II</a></h3><p>思路：把奇数和偶数分别存起来排序，然后赋值到数组中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] sortArrayByParityII(int[] nums) &#123;</span><br><span class="line">        List&lt;Integer&gt; j = new ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; o = new ArrayList&lt;&gt;();</span><br><span class="line">        for(int i=0;i&lt;nums.length;++i)&#123;</span><br><span class="line">            if(nums[i]%2==1)&#123;</span><br><span class="line">                j.add(nums[i]);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                o.add(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int index1 = 0;</span><br><span class="line">        int index2=0;</span><br><span class="line">        int i=0;</span><br><span class="line">        while(i&lt;nums.length)&#123;</span><br><span class="line">            if(i%2==1)&#123;</span><br><span class="line">                nums[i++]=j.get(index1++);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                nums[i++]=o.get(index2++);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路二：双指针</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] sortArrayByParityII(int[] nums) &#123;</span><br><span class="line">        int left =0;</span><br><span class="line">        int right=1;</span><br><span class="line">        while(right&lt;nums.length)&#123;</span><br><span class="line">            while(left&lt;nums.length &amp;&amp; nums[left]%2==0)&#123;</span><br><span class="line">                left+=2;</span><br><span class="line">            &#125;</span><br><span class="line">            while(right&lt;nums.length &amp;&amp; nums[right]%2==1)&#123;</span><br><span class="line">                right+=2;</span><br><span class="line">            &#125;</span><br><span class="line">            if(left&gt;=nums.length || right&gt;=nums.length)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            int tem = nums[left];</span><br><span class="line">            nums[left]=nums[right];</span><br><span class="line">            nums[right]=tem;</span><br><span class="line">        &#125;</span><br><span class="line">        return nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="搜索插入位置"><a href="#搜索插入位置" class="headerlink" title="搜索插入位置"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-insert-position/">搜索插入位置</a></h3><p>思路：二分法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int searchInsert(int[] nums, int target) &#123;</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = nums.length-1;</span><br><span class="line">        int mid = left + (right-left)/2;</span><br><span class="line">        while(left&lt;=right)&#123;</span><br><span class="line">            mid = left + (right-left)/2;</span><br><span class="line">            if(nums[mid]&gt;target)&#123;</span><br><span class="line">                right=mid-1;</span><br><span class="line">            &#125;else if(nums[mid]&lt;target)&#123;</span><br><span class="line">                left=mid+1;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return nums[mid]&lt;target?mid+1:mid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="回文链表"><a href="#回文链表" class="headerlink" title="回文链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindrome-linked-list/">回文链表</a></h3><p>思路：快慢指针找到中间节点，然后头插法翻转后半部分链表比较</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode() &#123;&#125;</span><br><span class="line"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="line"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isPalindrome(ListNode head) &#123;</span><br><span class="line">        ListNode fast = head.next;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        while(fast!=null &amp;&amp; fast.next != null)&#123;</span><br><span class="line">            fast=fast.next.next;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode virtual = new ListNode();</span><br><span class="line">        while(slow.next!=null)&#123;</span><br><span class="line">            ListNode tem = slow.next;</span><br><span class="line">            slow.next = tem.next;</span><br><span class="line">            tem.next = virtual.next;</span><br><span class="line">            virtual.next=tem;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode node = virtual.next;</span><br><span class="line">        while(node!=null)&#123;</span><br><span class="line">            if(node.val!=head.val)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            node=node.next;</span><br><span class="line">            head=head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="重排链表"><a href="#重排链表" class="headerlink" title="重排链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reorder-list/">重排链表</a></h3><p>思路：跟上题一样，先快慢指针找到中间节点，然后头插法反转，然后间隔插入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode() &#123;&#125;</span><br><span class="line"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="line"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public void reorderList(ListNode head) &#123;</span><br><span class="line">        if(head==null||head.next==null)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode fast = head.next;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        while(fast!=null&amp;&amp;fast.next!=null)&#123;</span><br><span class="line">            fast=fast.next.next;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode virtual = new ListNode();</span><br><span class="line">        while(slow.next!=null)&#123;</span><br><span class="line">            ListNode tem = slow.next;</span><br><span class="line">            slow.next=tem.next;</span><br><span class="line">            tem.next=virtual.next;</span><br><span class="line">            virtual.next=tem;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode p = head;</span><br><span class="line">        ListNode q = virtual.next;</span><br><span class="line">        while(q!=null)&#123;</span><br><span class="line">            ListNode t = q.next;</span><br><span class="line">            q.next=p.next;</span><br><span class="line">            p.next=q;</span><br><span class="line">            p=q.next;</span><br><span class="line">            q=t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle/">环形链表</a></h3><p>思路：经典快慢指针</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public boolean hasCycle(ListNode head) &#123;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        while(fast!=null&amp;&amp;fast.next!=null)&#123;</span><br><span class="line">            fast=fast.next.next;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">            if(fast==slow)&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><h3 id="同构字符串"><a href="#同构字符串" class="headerlink" title="同构字符串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/isomorphic-strings/">同构字符串</a></h3><p>思路：用map做映射，set做</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">sunsetsouol</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/02/17/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E9%A2%98%E8%A7%A3/">http://example.com/2025/02/17/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E9%A2%98%E8%A7%A3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">Coding Road</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%88%B7%E9%A2%98%E9%A2%98%E8%A7%A3/">刷题题解</a></div><div class="post-share"><div class="social-share" data-image="https://image.nickxu.me/202202230023069.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2025/02/17/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%96%87%E4%BB%B6%E5%8F%AA%E8%AF%BB%E5%BC%82%E5%B8%B8/" title="记一次服务器文件只读异常"><img class="cover" src="https://image.nickxu.me/202202230023069.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">记一次服务器文件只读异常</div></div><div class="info-2"><div class="info-item-1">nginx一直启动不了，报错是只读文件，这里修改文件的权限，还是失败，网上找了下原因 [linux系统变为只读，提示Read-only file system的解决办法-CSDN博客](https://blog.csdn.net/m0_38048955/article/details/135282591?ops_request_misc=%7B%22request%5Fid%22%3A%22171871318416800178594966%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=171871318416800178594966&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-135282591-null-null.142^v100^pc_search_result_base7&amp;utm_term=...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://qgstudio2024.oss-cn-guangzhou.aliyuncs.com/pic/202405171110049.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">sunsetsouol</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/sunsetsouol"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E5%88%B7%E9%A2%98"><span class="toc-number">1.</span> <span class="toc-text">代码随想录刷题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1%E6%95%B0%E7%BB%84"><span class="toc-number">2.</span> <span class="toc-text">1数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">2.1.</span> <span class="toc-text">1.1二分查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-1%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">2.1.1.</span> <span class="toc-text">1.1.1二分查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-2%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE"><span class="toc-number">2.1.2.</span> <span class="toc-text">1.1.2搜索插入位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-3%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE"><span class="toc-number">2.1.3.</span> <span class="toc-text">1.1.3在排序数组中查找元素的第一个和最后一个位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-4X%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9"><span class="toc-number">2.1.4.</span> <span class="toc-text">1.1.4X的平方根</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-5%E6%9C%89%E6%95%88%E7%9A%84%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0"><span class="toc-number">2.1.5.</span> <span class="toc-text">1.1.5有效的完全平方数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-number">2.2.</span> <span class="toc-text">1.2移除元素</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-number">2.2.1.</span> <span class="toc-text">1.2.1移除元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-2%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9"><span class="toc-number">2.2.2.</span> <span class="toc-text">1.2.2删除排序数组中的重复项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-3%E7%A7%BB%E5%8A%A8%E9%9B%B6"><span class="toc-number">2.2.3.</span> <span class="toc-text">1.2.3移动零</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-4%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">2.2.4.</span> <span class="toc-text">1.2.4比较含退格的字符串</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9"><span class="toc-number">2.3.</span> <span class="toc-text">1.3有序数组的平方</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">2.4.</span> <span class="toc-text">1.4长度最小的子数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-1%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">2.4.1.</span> <span class="toc-text">1.4.1长度最小的子数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-2%E6%B0%B4%E6%9E%9C%E6%88%90%E7%AF%AE"><span class="toc-number">2.4.2.</span> <span class="toc-text">1.4.2水果成篮</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-3%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%97%E4%B8%B2"><span class="toc-number">2.4.3.</span> <span class="toc-text">1.4.3最小覆盖字串</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5"><span class="toc-number">2.5.</span> <span class="toc-text">1.5螺旋矩阵</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-1%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5%E2%85%A1"><span class="toc-number">2.5.1.</span> <span class="toc-text">1.5.1螺旋矩阵Ⅱ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-2%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5"><span class="toc-number">2.5.2.</span> <span class="toc-text">1.5.2螺旋矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-3%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5"><span class="toc-number">2.5.3.</span> <span class="toc-text">1.5.3顺时针打印矩阵</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E9%93%BE%E8%A1%A8"><span class="toc-number">3.</span> <span class="toc-text">2.链表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0"><span class="toc-number">3.1.</span> <span class="toc-text">2.1移除链表元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8"><span class="toc-number">3.2.</span> <span class="toc-text">2.2设计链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-number">3.3.</span> <span class="toc-text">2.3翻转链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-number">3.4.</span> <span class="toc-text">2.4两两交换链表中的节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="toc-number">3.5.</span> <span class="toc-text">2.5删除链表中倒数第N个节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4"><span class="toc-number">3.6.</span> <span class="toc-text">2.6链表相交</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8"><span class="toc-number">3.7.</span> <span class="toc-text">2.7环形链表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">4.</span> <span class="toc-text">3.哈希表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E5%91%B3%E8%AF%8D"><span class="toc-number">4.1.</span> <span class="toc-text">3.1有效的字母异味词</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E5%91%B3%E8%AF%8D"><span class="toc-number">4.1.1.</span> <span class="toc-text">3.1.1有效的字母异味词</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2%E8%B5%8E%E9%87%91%E4%BF%A1"><span class="toc-number">4.1.2.</span> <span class="toc-text">3.1.2赎金信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-3%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84"><span class="toc-number">4.1.3.</span> <span class="toc-text">3.1.3字母异位词分组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-4%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D"><span class="toc-number">4.1.4.</span> <span class="toc-text">3.1.4找到字符串中所有字母异位词</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86"><span class="toc-number">4.2.</span> <span class="toc-text">3.2两个数组的交集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86"><span class="toc-number">4.2.1.</span> <span class="toc-text">3.2.1两个数组的交集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86%E2%85%A1"><span class="toc-number">4.2.2.</span> <span class="toc-text">3.2.2两个数组的交集Ⅱ</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3%E5%BF%AB%E4%B9%90%E6%95%B0"><span class="toc-number">4.3.</span> <span class="toc-text">3.3快乐数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">4.4.</span> <span class="toc-text">3.4两数之和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0"><span class="toc-number">4.5.</span> <span class="toc-text">3.5四数相加</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-1%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0%E2%85%A1"><span class="toc-number">4.5.1.</span> <span class="toc-text">3.5.1四数相加Ⅱ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-2%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">4.5.2.</span> <span class="toc-text">3.5.2三数之和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-3%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">4.5.3.</span> <span class="toc-text">3.5.3四数之和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">4.5.4.</span> <span class="toc-text">最接近的三数之和</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">5.</span> <span class="toc-text">4.字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">5.1.</span> <span class="toc-text">4.1反转字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E2%85%A1"><span class="toc-number">5.2.</span> <span class="toc-text">4.2反转字符串Ⅱ</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%8D%95%E8%AF%8D"><span class="toc-number">5.3.</span> <span class="toc-text">4.3翻转字符串的单词</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">5.4.</span> <span class="toc-text">4.4旋转字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-1%E5%8F%B3%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">5.4.1.</span> <span class="toc-text">4.4.1右旋转字符串</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5%E5%AE%9E%E7%8E%B0strStr"><span class="toc-number">5.5.</span> <span class="toc-text">*4.5实现strStr()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">5.6.</span> <span class="toc-text">*4.6重复的子字符串</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95"><span class="toc-number">6.</span> <span class="toc-text">5.双指针法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E7%89%88%E6%9C%AC%E5%8F%B7"><span class="toc-number">6.1.</span> <span class="toc-text">比较版本号</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="toc-number">7.</span> <span class="toc-text">6.栈和队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="toc-number">7.1.</span> <span class="toc-text">6.1用栈实现队列</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">8.</span> <span class="toc-text">7.二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">8.1.</span> <span class="toc-text">7.1前序遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">8.2.</span> <span class="toc-text">7.2后序遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">8.3.</span> <span class="toc-text">7.3中序遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">8.4.</span> <span class="toc-text">7.4层序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">8.4.1.</span> <span class="toc-text">7.4.1二叉树的层序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E2%85%A1"><span class="toc-number">8.4.2.</span> <span class="toc-text">7.4.2二叉树的层序遍历Ⅱ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-3%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE"><span class="toc-number">8.4.3.</span> <span class="toc-text">7.4.3二叉树的右视图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-4%E5%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC"><span class="toc-number">8.4.4.</span> <span class="toc-text">7.4.4层平均值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-4-N%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">8.4.5.</span> <span class="toc-text">7.4.4 N叉树的层序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-5-%E5%9C%A8%E6%AF%8F%E4%B8%AA%E6%A0%91%E8%A1%8C%E4%B8%AD%E6%89%BE%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-number">8.4.6.</span> <span class="toc-text">7.4.5 在每个树行中找最大值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-6-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88"><span class="toc-number">8.4.7.</span> <span class="toc-text">7.4.6 填充每个节点的下一个右侧节点指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-7-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88%E2%85%A1"><span class="toc-number">8.4.8.</span> <span class="toc-text">7.4.7 填充每个节点的下一个右侧节点指针Ⅱ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-8-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="toc-number">8.4.9.</span> <span class="toc-text">7.4.8 二叉树的最大深度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-9-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6"><span class="toc-number">8.4.10.</span> <span class="toc-text">7.4.9 二叉树的最小深度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-5-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">8.5.</span> <span class="toc-text">7.5 翻转二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-6-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">8.6.</span> <span class="toc-text">7.6 对称二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6-1-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">8.6.1.</span> <span class="toc-text">7.6.1 对称二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6-2-%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91"><span class="toc-number">8.6.2.</span> <span class="toc-text">7.6.2 相同的树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6-3%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91"><span class="toc-number">8.6.3.</span> <span class="toc-text">7.6.3另一个树的子树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-7-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="toc-number">8.7.</span> <span class="toc-text">7.7 二叉树的最大深度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-7-1-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="toc-number">8.7.1.</span> <span class="toc-text">7.7.1 二叉树的最大深度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-7-2-N%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="toc-number">8.7.2.</span> <span class="toc-text">7.7.2 N叉树的最大深度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-8-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6"><span class="toc-number">8.8.</span> <span class="toc-text">7.8 二叉树的最小深度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-9%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0"><span class="toc-number">8.9.</span> <span class="toc-text">7.9完全二叉树的节点个数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-10-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">8.10.</span> <span class="toc-text">7.10 平衡二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-11-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84"><span class="toc-number">8.11.</span> <span class="toc-text">7.11 二叉树的所有路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-12-%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C"><span class="toc-number">8.12.</span> <span class="toc-text">7.12 左叶子之和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-13-%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC"><span class="toc-number">8.13.</span> <span class="toc-text">7.13 找树左下角的值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-14-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C"><span class="toc-number">8.14.</span> <span class="toc-text">7.14 路径总和</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-14-1-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C"><span class="toc-number">8.14.1.</span> <span class="toc-text">7.14.1 路径总和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-14-2-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C%E2%85%A1"><span class="toc-number">8.14.2.</span> <span class="toc-text">7.14.2 路径总和Ⅱ</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-15-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E7%BB%AD%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">8.15.</span> <span class="toc-text">7.15 从中序与后续遍历序列构造二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-15-1-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E7%BB%AD%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">8.15.1.</span> <span class="toc-text">7.15.1 从中序与后续遍历序列构造二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-15-2-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">8.15.2.</span> <span class="toc-text">7.15.2 从前序与中序遍历序列构造二叉树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-16-%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">8.16.</span> <span class="toc-text">7.16 最大二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-17-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">8.17.</span> <span class="toc-text">7.17 合并二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-18-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%90%9C%E7%B4%A2"><span class="toc-number">8.18.</span> <span class="toc-text">7.18 二叉搜索树的搜索</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-19-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">8.19.</span> <span class="toc-text">7.19 验证二叉搜索树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-20-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE"><span class="toc-number">8.20.</span> <span class="toc-text">7.20 二叉搜索树的最小绝对差</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-21-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0"><span class="toc-number">8.21.</span> <span class="toc-text">7.21 二叉搜索树中的众数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-22-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-number">8.22.</span> <span class="toc-text">7.22 二叉树的最近公共祖先</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-23-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-number">8.23.</span> <span class="toc-text">7.23 二叉搜索树的最近公共祖先</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-24-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="toc-number">8.24.</span> <span class="toc-text">7.24 二叉搜索树中的插入操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-25-%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-number">8.25.</span> <span class="toc-text">7.25 删除二叉搜索树中的节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-26-%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">8.26.</span> <span class="toc-text">7.26 修剪二叉搜索树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-27-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">8.27.</span> <span class="toc-text">7.27 将有序数组转换为二叉搜索树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-28%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E6%88%90%E7%B4%AF%E5%8A%A0%E6%95%B0"><span class="toc-number">8.28.</span> <span class="toc-text">7.28把二叉搜索树转换成累加数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95"><span class="toc-number">9.</span> <span class="toc-text">8.回溯算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98"><span class="toc-number">9.1.</span> <span class="toc-text">8.1 组合问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E2%85%A2"><span class="toc-number">9.2.</span> <span class="toc-text">8.2 组合总和Ⅲ</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88"><span class="toc-number">9.3.</span> <span class="toc-text">8.3 电话号码的字母组合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-4-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C"><span class="toc-number">9.4.</span> <span class="toc-text">8.4 组合总和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-5-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E2%85%A1"><span class="toc-number">9.5.</span> <span class="toc-text">8.5 组合总和Ⅱ</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-6-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2"><span class="toc-number">9.6.</span> <span class="toc-text">8.6 分割回文串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-7-%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80"><span class="toc-number">9.7.</span> <span class="toc-text">8.7 复原IP地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-8-%E5%AD%90%E9%9B%86"><span class="toc-number">9.8.</span> <span class="toc-text">8.8 子集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-9-%E5%AD%90%E9%9B%86%E2%85%A1"><span class="toc-number">9.9.</span> <span class="toc-text">8.9 子集Ⅱ</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-10-%E9%9D%9E%E9%80%92%E5%87%8F%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">9.10.</span> <span class="toc-text">8.10 非递减子序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-11-%E5%85%A8%E6%8E%92%E5%88%97"><span class="toc-number">9.11.</span> <span class="toc-text">8.11 全排列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-12-%E5%85%A8%E6%8E%92%E5%88%97%E2%85%A1"><span class="toc-number">9.12.</span> <span class="toc-text">8.12 全排列Ⅱ</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-13-%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B"><span class="toc-number">9.13.</span> <span class="toc-text">*8.13 重新安排行程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-14-N%E7%9A%87%E5%90%8E"><span class="toc-number">9.14.</span> <span class="toc-text">8.14 N皇后</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-15-%E8%A7%A3%E6%95%B0%E7%8B%AC"><span class="toc-number">9.15.</span> <span class="toc-text">8.15 解数独</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="toc-number">10.</span> <span class="toc-text">9.贪心算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2"><span class="toc-number">10.1.</span> <span class="toc-text">9.1分发饼干</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97"><span class="toc-number">10.2.</span> <span class="toc-text">9.2摆动序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C"><span class="toc-number">10.3.</span> <span class="toc-text">9.3最大子序和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-4%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E2%85%A1"><span class="toc-number">10.4.</span> <span class="toc-text">9.4买卖股票的最佳时机Ⅱ</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-5%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F"><span class="toc-number">10.5.</span> <span class="toc-text">9.5跳跃游戏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-6%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F%E2%85%A1"><span class="toc-number">10.6.</span> <span class="toc-text">9.6跳跃游戏Ⅱ</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-7K%E6%AC%A1%E5%8F%96%E5%8F%8D%E5%90%8E%E6%9C%80%E5%A4%A7%E5%8C%96%E7%9A%84%E6%95%B0%E7%BB%84%E5%92%8C"><span class="toc-number">10.7.</span> <span class="toc-text">9.7K次取反后最大化的数组和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-8%E5%8A%A0%E6%B2%B9%E7%AB%99"><span class="toc-number">10.8.</span> <span class="toc-text">9.8加油站</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-9%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C"><span class="toc-number">10.9.</span> <span class="toc-text">*9.9分发糖果</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-10%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6"><span class="toc-number">10.10.</span> <span class="toc-text">9.10柠檬水找零</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-11%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97"><span class="toc-number">10.11.</span> <span class="toc-text">*9.11根据身高重建队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-12%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83"><span class="toc-number">10.12.</span> <span class="toc-text">9.12用最少数量的箭引爆气球</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-13%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4"><span class="toc-number">10.13.</span> <span class="toc-text">9.13无重叠区间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-14%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4"><span class="toc-number">10.14.</span> <span class="toc-text">9.14划分字母区间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-15%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4"><span class="toc-number">10.15.</span> <span class="toc-text">9.15合并区间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-16%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-number">10.16.</span> <span class="toc-text">9.16单调递增的数字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-17%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">10.17.</span> <span class="toc-text">9.17监控二叉树</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">11.</span> <span class="toc-text">10.动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#10-1%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97"><span class="toc-number">11.1.</span> <span class="toc-text">10.1斐波那契数列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-2%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="toc-number">11.2.</span> <span class="toc-text">10.2爬楼梯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-3%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="toc-number">11.3.</span> <span class="toc-text">10.3使用最小花费爬楼梯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-4%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84"><span class="toc-number">11.4.</span> <span class="toc-text">10.4不同路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-5%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%E2%85%A1"><span class="toc-number">11.5.</span> <span class="toc-text">10.5不同路径Ⅱ</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-6%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86"><span class="toc-number">11.6.</span> <span class="toc-text">10.6整数拆分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-7%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">11.7.</span> <span class="toc-text">10.7不同的二叉搜索树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-8-0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">11.8.</span> <span class="toc-text">10.8 0-1背包问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-9%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86"><span class="toc-number">11.9.</span> <span class="toc-text">10.9分割等和子集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-10%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F%E2%85%A1"><span class="toc-number">11.10.</span> <span class="toc-text">10.10最后一块石头的重量Ⅱ</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-11%E7%9B%AE%E6%A0%87%E5%92%8C"><span class="toc-number">11.11.</span> <span class="toc-text">10.11目标和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-12%E4%B8%80%E5%92%8C%E9%9B%B6"><span class="toc-number">11.12.</span> <span class="toc-text">10.12一和零</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-13%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85"><span class="toc-number">11.13.</span> <span class="toc-text">10.13完全背包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-14%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2%E2%85%A1"><span class="toc-number">11.14.</span> <span class="toc-text">10.14零钱兑换Ⅱ</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-15%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E2%85%A3"><span class="toc-number">11.15.</span> <span class="toc-text">10.15组合总和Ⅳ</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-16%E7%88%AC%E6%A5%BC%E6%A2%AF%E2%85%A1"><span class="toc-number">11.16.</span> <span class="toc-text">10.16爬楼梯Ⅱ</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-17%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2"><span class="toc-number">11.17.</span> <span class="toc-text">10.17零钱兑换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-18%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0"><span class="toc-number">11.18.</span> <span class="toc-text">10.18完全平方数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-19%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86"><span class="toc-number">11.19.</span> <span class="toc-text">10.19单词拆分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-20%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85"><span class="toc-number">11.20.</span> <span class="toc-text">10.20多重背包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-21%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D"><span class="toc-number">11.21.</span> <span class="toc-text">10.21打家劫舍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-22%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E2%85%A1"><span class="toc-number">11.22.</span> <span class="toc-text">10.22打家劫舍Ⅱ</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-23%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E2%85%A2"><span class="toc-number">11.23.</span> <span class="toc-text">10.23打家劫舍Ⅲ</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-24%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA"><span class="toc-number">11.24.</span> <span class="toc-text">10.24买卖股票的最佳时机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-25%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E2%85%A1"><span class="toc-number">11.25.</span> <span class="toc-text">10.25买卖股票的最佳时机Ⅱ</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-26%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E2%85%A2"><span class="toc-number">11.26.</span> <span class="toc-text">10.26买卖股票的最佳时机Ⅲ</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-27%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E2%85%A3"><span class="toc-number">11.27.</span> <span class="toc-text">10.27买卖股票的最佳时机Ⅳ</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-28%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F"><span class="toc-number">11.28.</span> <span class="toc-text">10.28买卖股票的最佳时机含冷冻期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-29%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9"><span class="toc-number">11.29.</span> <span class="toc-text">10.29买卖股票的最佳时机含手续费</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-30%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">11.30.</span> <span class="toc-text">10.30最长递增子序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-31%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97"><span class="toc-number">11.31.</span> <span class="toc-text">10.31最长连续递增序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-32%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">11.32.</span> <span class="toc-text">10.32最长重复子数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-33%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">11.33.</span> <span class="toc-text">10.33最长公共子序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-34%E4%B8%8D%E7%9B%B8%E4%BA%A4%E7%9A%84%E7%BA%BF"><span class="toc-number">11.34.</span> <span class="toc-text">10.34不相交的线</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-35%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C"><span class="toc-number">11.35.</span> <span class="toc-text">10.35最大子序和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-36%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">11.36.</span> <span class="toc-text">10.36判断子序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-37%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">11.37.</span> <span class="toc-text">10.37不同的子序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-38%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-number">11.38.</span> <span class="toc-text">10.38两个字符串的删除操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-39%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB"><span class="toc-number">11.39.</span> <span class="toc-text">10.39编辑距离</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-40%E5%9B%9E%E6%96%87%E5%AD%97%E4%B8%B2"><span class="toc-number">11.40.</span> <span class="toc-text">10.40回文字串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-41%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">11.41.</span> <span class="toc-text">10.41最长回文子序列</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11%E5%8D%95%E8%B0%83%E6%A0%88"><span class="toc-number">12.</span> <span class="toc-text">11单调栈</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11-1%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6"><span class="toc-number">12.1.</span> <span class="toc-text">11.1每日温度</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">13.</span> <span class="toc-text">其他</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">13.1.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%A4%9A%E5%B0%91%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E6%95%B0%E5%AD%97%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-number">13.1.1.</span> <span class="toc-text">有多少小于当前数字的数字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E6%95%88%E7%9A%84%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84"><span class="toc-number">13.1.2.</span> <span class="toc-text">有效的山脉数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8B%AC%E4%B8%80%E6%97%A0%E4%BA%8C%E7%9A%84%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0"><span class="toc-number">13.1.3.</span> <span class="toc-text">独一无二的出现次数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E9%9B%B6"><span class="toc-number">13.1.4.</span> <span class="toc-text">移动零</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84"><span class="toc-number">13.1.5.</span> <span class="toc-text">轮转数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E4%B8%8B%E6%A0%87"><span class="toc-number">13.1.6.</span> <span class="toc-text">寻找数组的中心下标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E5%A5%87%E5%81%B6%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84-II"><span class="toc-number">13.1.7.</span> <span class="toc-text"> 按奇偶排序数组 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE"><span class="toc-number">13.1.8.</span> <span class="toc-text">搜索插入位置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">13.2.</span> <span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8"><span class="toc-number">13.2.1.</span> <span class="toc-text">回文链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8"><span class="toc-number">13.2.2.</span> <span class="toc-text">重排链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8"><span class="toc-number">13.2.3.</span> <span class="toc-text">环形链表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">13.3.</span> <span class="toc-text">哈希表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">13.3.1.</span> <span class="toc-text">同构字符串</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/17/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/" title="装饰器模式">装饰器模式</a><time datetime="2025-02-17T03:47:47.000Z" title="发表于 2025-02-17 11:47:47">2025-02-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/17/%E5%8E%9F%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="原型设计模式">原型设计模式</a><time datetime="2025-02-17T03:47:42.000Z" title="发表于 2025-02-17 11:47:42">2025-02-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/17/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/" title="享元模式">享元模式</a><time datetime="2025-02-17T03:47:33.000Z" title="发表于 2025-02-17 11:47:33">2025-02-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/17/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/" title="适配器模式">适配器模式</a><time datetime="2025-02-17T03:47:24.000Z" title="发表于 2025-02-17 11:47:24">2025-02-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/17/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/" title="建造者模式">建造者模式</a><time datetime="2025-02-17T03:47:19.000Z" title="发表于 2025-02-17 11:47:19">2025-02-17</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By sunsetsouol</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.3</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>